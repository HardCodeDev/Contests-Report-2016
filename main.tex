%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper,12pt]{article}
%\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{titlesec}

\usepackage{longtable}
\usepackage{ltxtable}

\usepackage{listings}
\usepackage{color}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    %backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,
    urlcolor=blue,
}

\urlstyle{same}

\usepackage{geometry}
\geometry{top=2cm}
\geometry{bottom=2cm}
\geometry{left=1.5cm}
\geometry{right=1.5cm}


\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page



%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{\large Московский Авиационный Институт\\(национальный исследовательский университет)}\\[1.5cm] % Name of your university/college



%----------------------------------------------------------------------------------------
%	LOGO SECTION
%----------------------------------------------------------------------------------------

\includegraphics[width=0.25\textwidth]{mai.png}\\[1cm]
% Include a department/university logo - this will require the graphicx package

%----------------------------------------------------------------------------------------

\vspace{40px}

\textsc{\Large Отчет по индивидуальному учебному плану}\\[0.5cm] % Major heading such as course name
%\textsc{\large Алгоритмы на графах}\\[0.5cm] % Minor heading such as course title



%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries Фундаментальные алгоритмы}\\[0.4cm] % Title of your document
\HRule \\[1.5cm]



%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Студенты:}\\
%John \textsc{Smith} % Your name
Макаров Никита, 8о-406Б\\Якименко Антон, 8о-406Б
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Руководитель:} \\
%Dr. James \textsc{Smith} % Supervisor's Name
Зайцев В.Е.
\end{flushright}
\end{minipage}\\[2cm]

%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------

\vspace{190px}
{\large Москва\\2016}\\[2cm] % Date, change the \today to a set date if you want to be precise

\vfill % Fill the rest of the page with whitespace

\end{titlepage}



%----------------------------------------------------------------------------------------
%	СОДЕРЖАНИЕ
%----------------------------------------------------------------------------------------
\tableofcontents
\newpage



%----------------------------------------------------------------------------------------
%	ЛИЧНЫЕ ОТЧЕТЫ
%----------------------------------------------------------------------------------------
\section{Личные отчеты}

% Мой отчет
Отчет о работе студента Макарова Н.А. по индивидуальному учебному плану в V-VI семестрах 2014-2015 учебного года.

% Таблица - часть 1
\begin{table}[ht!]
\centering
\label{my-tab1}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline

% Заголовки столбцов
№ &
Дата &
Контест &
\begin{tabular}[c]{@{}c@{}}Место\\ проведения\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Кол-во\\ участников\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Решено\\ задач\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Задач на\\ участника\end{tabular} \\ \hline

% Строки таблицы
1 & 18.09.2014 & Codeforces Round 267 Div 2 & Дом & 1 & 2 & 2 \\ \hline

2 & 21.09.2014 & Codeforces Round 268 Div 2 & Дом & 1 & 2 & 2 \\ \hline

3 & 22.09.2014 & \begin{tabular}[c]{@{}c@{}}Codeforces Отборочный контест\\ СГАУ на 1/4 ACM-ICPC\end{tabular} & Дом & 1 & 3 & 3 \\ \hline

4 & 25.09.2014 & Codeforces Training S02E03 & МАИ & 3 & 3 & 1 \\ \hline

5 & 28.09.2014 & Codeforces Round 270 Div 2 & Дом & 1 & 2 & 2 \\ \hline

6 & 02.10.2014 & Codeforces Training S02E04 & МАИ & 3 & 1 & 0.33 \\ \hline

7 & 05.10.2014 & \begin{tabular}[c]{@{}c@{}}XV Открытая Всесибирская\\ Олимпиада по\\ Программированию\end{tabular} & МАИ & 3 & 1 & 0.33 \\ \hline

8 & 09.10.2014 & Codeforces Training S02E05 & МАИ & 3 & 4 & 1.33 \\ \hline

9 & 16.10.2014 & Codeforces Round 273 Div 2 & Дом & 1 & 2 & 2 \\ \hline

10 & 17.10.2014 & Codeforces Training S02E06 & МАИ & 3 & 0 & 0 \\ \hline

11 & 18.10.2014 & \begin{tabular}[c]{@{}c@{}}Codeforces Тренировка СПбГУ\\ графы и DFS\end{tabular} & Дом & 3 & 2 & 0.66 \\ \hline

12 & 19.10.2014 & OpenCup GP of SPb. Div 2 & МАИ & 3 & 1 & 0.33 \\ \hline

13 & 20.10.2014 & Codeforces Round 274 Div 2 & Дом & 1 & 3 & 3 \\ \hline

14 & 23.10.2014 & \begin{tabular}[c]{@{}c@{}}Codeforces Самарский\\Аэрокосмический Лицей\\ тренировка №1\end{tabular} & Дом & 2 & 1 & 0.5 \\ \hline

15 & 23.10.2014 & \begin{tabular}[c]{@{}c@{}}Codeforces ACM, NEERC,\\ Восточный четвертьфинал\end{tabular} & Дом & 3 & 4 & 1.33 \\ \hline

16 & 24.10.2014 & Codeforces Round 275 Div 2 & Дом & 1 & 1 & 1 \\ \hline

17 & 25.10.2014 & \begin{tabular}[c]{@{}c@{}}Codeforces ACM, NEERC,\\ Южный четвертьфинал\end{tabular} & Дом & 3 & 3 & 1 \\ \hline

18 & 26.10.2014 & ACM-ICPC 1/4 Final & МГУ & 3 & 3 & 1 \\ \hline

19 & 30.10.2014 & Codeforces Training S02E07 & МАИ & 3 & 2 & 0.66 \\ \hline

20 & 01.11.2014 & Codeforces Crypto Cup & Дом & 3 & 9 & 3 \\ \hline

21 & 02.11.2014 & OpenCup GP of Siberia Div 2 & МАИ & 2 & 3 & 1.5 \\ \hline

22 & 06.11.2014 & Codeforces Training S02E08 & МАИ & 3 & 2 & 0.66 \\ \hline

23 & 13.11.2014 & Codeforces Training S02E09 & МАИ & 3 & 3 & 1 \\ \hline

24 & 15.11.2014 & \begin{tabular}[c]{@{}c@{}}Codeforces Олимпиада\\ школьников\\ Нижегородской области\end{tabular} & Дом & 2 & 3 & 1.5 \\ \hline

25 & 16.11.2014 & \begin{tabular}[c]{@{}c@{}}OpenCup GP\\ of Central Europe. Div 2\end{tabular} & МАИ & 3 & 1 & 0.33 \\ \hline

26 & 20.11.2014 & Codeforces Training S02E10 & МАИ & 3 & 3 & 1 \\ \hline

27 & 23.11.2014 & OpenCup GP of Europe Div 2 & МАИ & 3 & 5 & 1.66 \\ \hline

28 & 14.12.2014 & OpenCup GP of Peterhof Div 2 & МАИ & 3 & 1 & 0.33 \\ \hline

29 & 01.02.2015 & OpenCup GP of Japan Div 2 & МАИ & 3 & 4 & 1.33 \\ \hline

30 & 08.02.2015 & OpenCup Northern GP Div 2 & МАИ & 3 & 2 & 0.66 \\ \hline

31 & 15.02.2015 & OpenCup GP of Karelia Div 2 & МАИ & 3 & 4 & 1.33 \\ \hline

\end{tabular}
\end{table}

Продолжение таблицы.
% Таблица - часть 2
\begin{table}[ht!]
\centering
%\caption{My caption}
\label{my-tab2}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline

% Заголовки столбцов
№ &
Дата &
Контест &
\begin{tabular}[c]{@{}c@{}}Место\\ проведения\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Кол-во\\ участников\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Решено\\ задач\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Задач на\\ участника\end{tabular} \\ \hline

% Строки таблицы
32 & 22.02.2015 & OpenCup GP of Udmurtia Div 2 & МАИ & 3 & 4 & 1.33 \\ \hline

33 & 01.03.2015 & OpenCup GP of China Div 2 & МАИ & 3 & 1 & 0.33 \\ \hline

34 & 07.03.2015 & VK Cup 2015 Квалификация & Дом & 1 & 2 & 2 \\ \hline

35 & 15.03.2015 & OpenCup GP of Tatarstan Div 2 & МАИ & 3 & 1 & 0.33 \\ \hline

36 & 21.03.2015 & VK Cup 2015 Раунд 1 & Дом & 1 & 2 & 2 \\ \hline

37 & 29.03.2015 & OpenCup Gp of America Div 2 & МАИ & 3 & 4 & 1.33 \\ \hline

38 & 18.04.2015 & Vekua Cup Личный этап & МФТИ-1С & 1 & 1 & 1 \\ \hline

39 & 19.04.2015 & Vekua Cup Командный этап & МФТИ-1С & 3 & 3 & 1 \\ \hline

40 & 26.04.2015 & OpenCup GP of Ural Div 2 & МАИ & 2 & 2 & 1 \\ \hline

41 & 31.05.2105 & Mail.ru RCC Квалификация & Дом & 1 & 1 & 1 \\ \hline

\end{tabular}
\end{table}

Итого: 41 контест, 101 решенная задача. Личный вклад $\approx$49 задач (командные + личные). \\

\noindent Студент:\underline{\hspace{3cm}} Макаров Н.А.\hfill Руководитель:\underline{\hspace{3cm}} Зайцев В.Е.

\newpage

% Отчет Антона

Отчет о работе студента Якименко А.В. по индивидуальному учебному плану в V-VI семестрах 2014-2015 учебного года.

% Таблица - часть 1
\begin{table}[ht!]
\centering
\label{my-tab11}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline

% Заголовки столбцов
№ &
Дата &
Контест &
\begin{tabular}[c]{@{}c@{}}Место\\ проведения\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Кол-во\\ участников\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Решено\\ задач\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Задач на\\ участника\end{tabular} \\ \hline

% Строки таблицы

1 & 18.09.2014 & Codeforces Round 267 Div 2 & Дом & 1 & 2 & 2 \\ \hline

2 & 21.09.2014 & Codeforces Round 268 Div 2 & Дом & 1 & 2 & 2 \\ \hline

3 & 22.09.2014 & \begin{tabular}[c]{@{}c@{}}Codeforces Отборочный контест\\ СГАУ на 1/4 ACM-ICPC\end{tabular} & Дом & 1 & 1 & 1 \\ \hline

4 & 25.09.2014 & Codeforces Training S02E03 & МАИ & 3 & 3 & 1 \\ \hline

5 & 26.09.2014 & Codeforces Round 269 Div 2 & Дом & 1 & 1 & 1 \\ \hline

6 & 28.09.2014 & Codeforces Round 270 Div 2 & Дом & 1 & 2 & 2 \\ \hline

7 & 02.10.2014 & Codeforces Training S02E04 & МАИ & 3 & 1 & 0.33 \\ \hline

8 & 05.10.2014 & \begin{tabular}[c]{@{}c@{}}XV Открытая Всесибирская\\ Олимпиада по\\ Программированию\end{tabular} & МАИ & 3 & 1 & 0.33 \\ \hline

9 & 09.10.2014 & Codeforces Training S02E05 & МАИ & 3 & 4 & 1.33 \\ \hline

10 & 12.10.2014 & Codeforces Round 272 Div 2 & Дом & 1 & 2 & 2 \\ \hline

11 & 16.10.2014 & Codeforces Round 273 Div 2 & Дом & 1 & 2 & 2 \\ \hline

12 & 17.10.2014 & Codeforces Training S02E06 & МАИ & 3 & 0 & 0 \\ \hline

13 & 18.10.2014 & \begin{tabular}[c]{@{}c@{}}Codeforces Тренировка СПбГУ\\ графы и DFS\end{tabular} & Дом & 3 & 2 & 0.66 \\ \hline

14 & 19.10.2014 & OpenCup GP of SPb. Div 2 & МАИ & 3 & 1 & 0.33 \\ \hline

15 & 20.10.2014 & Codeforces Round 274 Div 2 & Дом & 1 & 3 & 3 \\ \hline

16 & 23.10.2014 & \begin{tabular}[c]{@{}c@{}}Codeforces Самарский\\Аэрокосмический Лицей\\ тренировка №1\end{tabular} & Дом & 2 & 1 & 0.5 \\ \hline

17 & 23.10.2014 & \begin{tabular}[c]{@{}c@{}}Codeforces ACM, NEERC,\\ Восточный четвертьфинал\end{tabular} & Дом & 3 & 4 & 1.33 \\ \hline

18 & 24.10.2014 & Codeforces Round 275 Div 2 & Дом & 1 & 1 & 1 \\ \hline

19 & 25.10.2014 & \begin{tabular}[c]{@{}c@{}}Codeforces ACM, NEERC,\\ Южный четвертьфинал\end{tabular} & Дом & 3 & 3 & 1 \\ \hline

20 & 26.10.2014 & ACM-ICPC 1/4 Final & МГУ & 3 & 3 & 1 \\ \hline

21 & 30.10.2014 & Codeforces Training S02E07 & МАИ & 3 & 2 & 0.66 \\ \hline

22 & 01.11.2014 & Codeforces Crypto Cup & Дом & 3 & 9 & 3 \\ \hline

23 & 02.11.2014 & OpenCup GP of Siberia Div 2 & МАИ & 2 & 3 & 1.5 \\ \hline

24 & 05.11.2014 & Codeforces Round 276 Div 2 & Дом & 1 & 3 & 3 \\ \hline

25 & 06.11.2014 & Codeforces Training S02E08 & МАИ & 3 & 2 & 0.66 \\ \hline

26 & 11.11.2014 & Codeforces Round 277 Div 2 & Дом & 1 & 2 & 2 \\ \hline

27 & 13.11.2014 & Codeforces Training S02E09 & МАИ & 3 & 3 & 1 \\ \hline

28 & 15.11.2014 & \begin{tabular}[c]{@{}c@{}}Codeforces Олимпиада\\ школьников\\ Нижегородской области\end{tabular} & Дом & 2 & 3 & 1.5 \\ \hline

29 & 16.11.2014 & \begin{tabular}[c]{@{}c@{}}OpenCup GP\\ of Central Europe. Div 2\end{tabular} & МАИ & 3 & 1 & 0.33 \\ \hline

30 & 17.11.2014 & Codeforces Round 277.5 Div 2 & Дом & 1 & 4 & 4 \\ \hline

31 & 20.11.2014 & Codeforces Training S02E10 & МАИ & 3 & 3 & 1 \\ \hline

32 & 23.11.2014 & OpenCup GP of Europe Div 2 & МАИ & 3 & 5 & 1.66 \\ \hline

33 & 14.12.2014 & OpenCup GP of Peterhof Div 2 & МАИ & 3 & 1 & 0.33 \\ \hline

\end{tabular}
\end{table}

Продолжение таблицы.
% Таблица - часть 2
\begin{table}[ht!]
\centering
%\caption{My caption}
\label{my-tab22}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline

% Заголовки столбцов
№ &
Дата &
Контест &
\begin{tabular}[c]{@{}c@{}}Место\\ проведения\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Кол-во\\ участников\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Решено\\ задач\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Задач на\\ участника\end{tabular} \\ \hline

% Строки таблицы

34 & 01.02.2015 & OpenCup GP of Japan Div 2 & МАИ & 3 & 4 & 1.33 \\ \hline

35 & 08.02.2015 & OpenCup Northern GP Div 2 & МАИ & 3 & 2 & 0.66 \\ \hline

36 & 15.02.2015 & OpenCup GP of Karelia Div 2 & МАИ & 3 & 4 & 1.33 \\ \hline

37 & 22.02.2015 & OpenCup GP of Udmurtia Div 2 & МАИ & 3 & 4 & 1.33 \\ \hline

38 & 01.03.2015 & OpenCup GP of China Div 2 & МАИ & 3 & 1 & 0.33 \\ \hline

39 & 14.03.2015 & VK Cup 2015 Квалификация 2 & Дом & 1 & 2 & 2 \\ \hline

40 & 15.03.2015 & OpenCup GP of Tatarstan Div 2 & МАИ & 3 & 1 & 0.33 \\ \hline

41 & 21.03.2015 & VK Cup 2015 Раунд 1 & Дом & 1 & 1 & 1 \\ \hline

42 & 28.03.2015 & \begin{tabular}[c]{@{}c@{}}VK Cup 2015 -\\ Уайлд-кард раунд 1\end{tabular} & Дом & 1 & 2 & 2 \\ \hline

43 & 29.03.2015 & OpenCup Gp of America Div 2 & МАИ & 3 & 4 & 1.33 \\ \hline

44 & 18.04.2015 & Vekua Cup Личный этап & МФТИ-1С & 1 & 1 & 1 \\ \hline

45 & 19.04.2015 & Vekua Cup Командный этап & МФТИ-1С & 3 & 3 & 1 \\ \hline

46 & 26.04.2015 & OpenCup GP of Ural Div 2 & МАИ & 2 & 2 & 1 \\ \hline

\end{tabular}
\end{table}

Итого: 46 контестов, 108 решенных задач. Личный вклад $\approx$55 задач (командные + личные). \\

\noindent Студент:\underline{\hspace{3cm}} Якименко А.В.\hfill Руководитель:\underline{\hspace{3cm}} Зайцев В.Е.




\newpage
%----------------------------------------------------------------------------------------
%	КОМАНДНЫЕ КОНТЕСТЫ
%----------------------------------------------------------------------------------------
\section{Журнал по командным контестам}



%----------------------------------------------------------------------------------------
%
%	OpenCup GrandPrix of Ukraine
%
%----------------------------------------------------------------------------------------
\subsection{OpenCup GrandPrix of Ukraine (4 solved) + (алгоритм в F)}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Ukraine/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10321}}}

\newpage
\textbf{{\large Задача C - Cool Numbers}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Ukraine/C.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Для решения данной задачи можно написать генератор весёлых чисел, который посчитает первые 1000 весёлых чисел, а затем уже выводить ответ используя сгенерированные числа. Cложность решения $O(1)$. \\

%\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
int main(int argc, const char * argv[]) {
    int nums[] = {13,  17, .. (generated numbers) .., 70529,  70573};
    int k;
    std::cin >> k;
    std::cout << nums[k - 1];
    return 0;
}
\end{lstlisting}


\newpage
\textbf{{\large Задача D - Diagram}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Ukraine/D.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче можно воспользоваться хитростью. Так как нужное количество чисел чтобы построить окружность не поместится в памяти, будем использовать битовый массив, показывающий наличие точки на окружности в заданных координатах. Затем просто пройдем по массиву и попытаемся собрать нужную последовательность. Сложность алгоритма $O(N * K)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#define ULL unsigned long long
int main() {
    ULL *array = (ULL *)malloc(15500000 * sizeof(ULL));
    ULL p;
    for (p = 0; p < 15000000; p++) {
        array[p] = 0;
    }
    ULL N, K;
    scanf("%lld %lld", &N, &K);
    ULL i;
    int r = 64;
    for (i = 0; i < N; i++) {
        ULL dist;
        scanf("%lld", &dist);
        array[dist/r] |= (1LL << (dist % r));
    }
    ULL max_length;
    scanf("%lld", &max_length);
    const ULL part_size = max_length / K;
    for (i = 0; i < part_size; i++) {
        ULL index = i / r;
        int shift = i % r;
        bool found = true;
        if (array[index] & (1LL << shift)) {
            ULL j;
            for (j = i + part_size; j < max_length; j += part_size) {
                ULL j_index = j / r;
                int j_shift = j % r;
                if (!(array[j_index] & (1LL << j_shift))) {
                    found = false;
                    break;
                }
            }
            if (found) {
                printf("1\n");
                return 0;
            }
        }
    }
    printf("0\n");
    return 0;
}
\end{lstlisting}


\newpage
\textbf{{\large Задача F - First And Last}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Ukraine/F.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

\textcolor{red}{\Huge{АНТОН ????}}. \\


%\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
use bigint;
my($a, $b) = split " ", <>;
my $p = 1;
for my $n (0..1000) {
	if (($a eq $b && $p eq $a) || $p =~ m/^$a.*?$b$/) {
		print $n, "\n";
		exit;
	}
	$p <<= 1;
}
print "-1\n";
\end{lstlisting}


\newpage
\textbf{{\large Задача G - Game of Solitaire}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Ukraine/G.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно заметить, что ответом будет наибольший общий делитель входных чисел. НОД находим с помощью алгоритма Евклида. Сложность решения $O(log * min(a, b)$ \\


%\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
long gcd (long a, long b) {
    while (b) {
        a %= b;
        swap(a, b);
    }
    return a;
}
int main() {
    long n, k;
    cin >> n >> k;
    cout << gcd(n, k);
    return 0;
}
\end{lstlisting}






%----------------------------------------------------------------------------------------
%
%	OpenCup GrandPrix of Japan
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Japan (5 solved) + DONE}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Japan/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10322}}}


\newpage
\textbf{{\large Задача A - Where is the Boundary}} \\

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Japan/A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно просто считать все данные и перебрать все значения ошибок, запоминая индексы минимальных значений. Сложность $O(N * M)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <map>
using namespace std;
typedef struct {
    int left;
    int rigth;
    int sum;
} error;
int main(int argc, const char * argv[]) {
    int n, m;
    cin >> n >> m;
    vector< map<string,int> > jag(n);
    for (int i = 0; i < n; i++) {
        jag[i]["w"] = 0;
        jag[i]["e"] = 0;
    }
    vector<error> errors (n + 1);
    errors[0].left = 0;
    errors[0].rigth = 0;
    errors[0].sum = 0;
    for (int i = 0; i < m; i++) {
        string features;
        cin >> features;
        for (size_t j = 0; j < features.size(); j++) {
            if (features[j] == 'W') {
                jag[j]["w"]++;
                errors[0].rigth++; // !!!!!!
            } else {
                jag[j]["e"]++;
            }
        }
    }
    errors[0].sum = errors[0].left + errors[0].rigth;
    int min_error = errors[0].rigth;
    int min_error_index = -1;
    for (int i = 1; i < n + 1; i++) {
        errors[i].left = 0;
        errors[i].rigth = 0;
        errors[i].sum = 0;
        errors[i].left = errors[i - 1].left + jag[i - 1]["e"];
        errors[i].rigth = errors[i - 1].rigth - jag[i - 1]["w"];
        errors[i].sum = errors[i].left + errors[i].rigth;   
        if (errors[i].sum < min_error) {
            min_error = errors[i].sum;
            min_error_index = i;
        }
    }
    if (min_error_index == -1) {
        cout << "0 1" << endl;
    } else {
        cout << min_error_index << " " << min_error_index + 1 << endl;
    }   
    return 0;
}
\end{lstlisting}


\newpage
\textbf{{\large Задача G - Surface Area of Cubes}} \\

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Japan/G.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Данная задача на реализацию. Необходимо грамотно выстроить структуру и уметь находить изменение площади кубика после убирания кубика на заданных координатах. Сложность $O(N^2)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
using namespace std;
#define ll long long
class Point {
public:
	ll x, y, z;
	Point() {}
	Point(ll a, ll b, ll c) {
		x = a;
		y = b;
		z = c;
	}
	void setPoints(ll a, ll b, ll c) {
		x = a;
		y = b;
		z = c;
	}
	bool eql(ll a, ll b, ll c) {
		return a == x && b == y && c == z;
	}
};
int main() {
	ll a, b, c, n;
	cin >> a >> b >> c >> n;
	vector<Point> points(n);
	ll square = 2*(a*b + b*c + a*c);
	for (int i = 0; i < n; ++i) {
		ll x, y, z;
		cin >> x >> y >> z;
		points[i].setPoints(x, y, z);
		ll s = 0;
		if (x == 0) ++s;
		if (x == a-1) ++s;
		if (y == 0) ++s;
		if (y == b-1) ++s;
		if (z == 0) ++s;
		if (z == c-1) ++s;
		ll p = 0;
		for (int j = 0; j < i; ++j) {
			if (points[j].eql(x-1, y, z)) ++p;
			if (points[j].eql(x+1, y, z)) ++p;
			if (points[j].eql(x, y-1, z)) ++p;
			if (points[j].eql(x, y+1, z)) ++p;
			if (points[j].eql(x, y, z-1)) ++p;
			if (points[j].eql(x, y, z+1)) ++p;
		}
		square += 6-2*(s+p);
	}
	cout << square << "\n";
	return 0;
}
\end{lstlisting}



\newpage
\textbf{{\large Задача K - Emoticon Counter}} \\

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Japan/K.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче необходимо найти все вхождения радостных и грустный смайликов и вывести в ответе каких больше. Решается поиском подстроки в строке. Сложность $O(N * M)$. \\

%\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Ruby]
str = gets
str = str + "$"
happy = str.split(":-)")
sad = str.split(":-(")
if happy.size > sad.size
  puts "happy"
elsif happy.size < sad.size
  puts "sad"
else
  puts "neutral"
end
\end{lstlisting}


\newpage
\textbf{{\large Задача L - Rogue Language}} \\

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Japan/L.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно понять как меняются символы и просто сделать замену всех символов по составленному словарю замен. Сложность $O(1)$. \\

%\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
my %h = (
		a => "a", b => "bac",c => "cad",e => "e",f => "feg",
		g => "geh",h => "hij",i => "i",j => "jik",k => "kil",
		l => "lim",m => "mon",n => "nop",o => "o",p => "poq",
		q => "qor",r => "ros",s => "sut",t => "tuv",u => "u",
		v => "vuw",w => "wux",x => "xuy",y => "yuz",z => "zuz");
my $a = <>;
chomp $a;
my $res = "";
for my $i (split "", $a) {
	$res .= $h{$i};
}
print $res, "\n";
\end{lstlisting}


\newpage
\textbf{{\large Задача M - RPS}} \\

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Japan/M.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче упор на реализацию. Нужно просто пройти по входным строкам и сосчитать количество выигрышных партий у каждого из игроков. Сложность $O(N)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
my %h = (paper => 0, scissors => 1, rock => 2);
my $n = <>;
my $A = <>;
my $B = <>;
chomp $A;
chomp $B;
my @A = split " ", $A;
my @B = split " ", $B;
my ($ac, $bc) = (0, 0);
for (my $i = 0; $i < $n; ++$i) {
	my ($a, $b) = ($A[$i], $B[$i]);
	if ($a eq "paper" && $b eq "rock") {
		++$ac;
	}
	elsif ($b eq "paper" && $a eq "rock") {
		++$bc;
	}
	elsif ($h{$a} > $h{$b}) {
		++$ac;
	}
	elsif ($h{$a} < $h{$b}) {
		++$bc;
	}
}
print "$ac $bc\n";
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	OpenCup GrandPrix of Eurasia
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{OpenCup GrandPrix of Eurasia (4 solved) + (алгоритм в 9, 12)}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Eurasia/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10323}}}

\newpage
\textbf{{\large Задача 2 - Плэй-офф}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Eurasia/2_1.png}\\ [1cm]
\includegraphics[width=0.6\textwidth]{OC_Eurasia/2_2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Задача на реализацию. Мы строим дерево команд и каждой команде ставим в соответствие массив команд, которые слабее рассматриваемой. Затем мы считываем запросы и выводим ответ. Сложность алгоритма $O(Q * N * log(N))$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <fstream>
using namespace std;
typedef struct {
    string name;
    vector<string> losers;
} Team;
int main(int argc, const char * argv[]) {
    ifstream in("input.txt");
    ofstream out("output.txt");
    int n;
    in >> n;
    int t = 1;
    for (int i = 0; i < n; i++) {
        t *= 2;
    }
    map<int, vector<int> > teams; // first=team_name, second=losers_vector
    map<string, int> index_for_name;
    vector<pair<int, int> > pairs;
    vector<pair<int, int> > prev_pairs;
    vector<char> log(t - 1);
    for (int i = 0; i < t; i = i + 2) {
        string team_name_1, team_name_2;
        in >> team_name_1 >> team_name_2;
        index_for_name[team_name_1] = i;
        index_for_name[team_name_2] = i + 1;
        teams[i] = vector<int> ();
        teams[i + 1] = vector<int> ();
        pairs.push_back(make_pair(i, i + 1));
    }
    in.get();
    for (int i = 0; i < t - 1; i++) {
        char result = in.get();
        log[i] = result;
    }
    in.get();
    prev_pairs = pairs;
    pairs.clear();
    bool end = false;
    while (!end) {
        for (int i = 0; i < t / 2; i += 2) {
            int first_winner, first_looser;
            int second_winner, second_looser;
            if (log[i] == 'W') {
                first_winner = prev_pairs[i].first;
                first_looser = prev_pairs[i].second;
                teams[first_winner].push_back(first_looser);
                teams[first_winner].insert(teams[first_winner].end(), teams[first_looser].begin(), teams[first_looser].end());
            } else {
                first_winner = prev_pairs[i].second;
                first_looser = prev_pairs[i].first;
                teams[first_winner].push_back(first_looser);
                teams[first_winner].insert(teams[first_winner].end(), teams[first_looser].begin(), teams[first_looser].end());
            }
            if (i == t - 2) {
                end = true;
                break;
            }
            if (log[i + 1] == 'W') {
                second_winner = prev_pairs[i + 1].first;
                second_looser = prev_pairs[i + 1].second;
                teams[second_winner].push_back(second_looser);
                teams[second_winner].insert(teams[second_winner].end(), teams[second_looser].begin(), teams[second_looser].end());
            } else {
                second_winner = prev_pairs[i + 1].second;
                second_looser = prev_pairs[i + 1].first;
                teams[second_winner].push_back(second_looser);
                teams[second_winner].insert(teams[second_winner].end(), teams[second_looser].begin(), teams[second_looser].end());
            }
            pairs.push_back(make_pair(first_winner, second_winner));
        }
        log.erase(log.begin(), log.begin() + t / 2);
        prev_pairs = pairs;
        pairs.clear();
        t /= 2;
    }
    int q;
    in >> q;
    for (int i = 0; i < q; i++) {
        string t1, t2;
        in >> t1 >> t2;
        int index_1 = index_for_name[t1];
        int index_2 = index_for_name[t2];
        if (find(teams[index_1].begin(), teams[index_1].end(), index_2) != teams[index_1].end()) {
            out << "Win" << endl;
        } else if (find(teams[index_2].begin(), teams[index_2].end(), index_1) != teams[index_2].end()) {
            out << "Lose" << endl;
        } else {
            out << "Unknown" << endl;
        }
    }
    in.close();
    out.clear();
    return 0;
}
\end{lstlisting}


\newpage
\textbf{{\large Задача 9 - Хэш-функция}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Eurasia/9.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

\textcolor{red}{\Huge{АНТОН ????}}. \\

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <cinttypes>
using namespace std;
#define ll long long
#define ull unsigned long long

uint32_t dehash(uint32_t value) {
    uint32_t hash = value;
    hash = hash - (hash<<16);
    uint32_t t = hash;
	hash = (hash xor (hash >> 11)) & ~((1ULL<<10)-1);
	for (int i = 0; i < 1023; ++i) {
		if ((hash xor (hash >> 11)) == t) {
			break;
		}
		++hash;
	}
	ull h = hash;
	for (ull i = 0;; ++i) {
		if (((h|(i<<32)) % 9) == 0) {
			hash = (h|(i<<32))/9;
			break;
		}
	}
	t = hash;
	hash = (hash xor (hash >> 6)) & ~((1ULL<<20)-1);
	for (int i = 0; i < 1048575; ++i) {
		if ((hash xor (hash >> 6)) == t) {
			break;
		}
		++hash;
	}
	h = hash;
	for (ull i = 0;; ++i) {
		if (((h|(i<<32)) % 1025) == 0) {
			hash = (h|(i<<32))/1025;
			break;
		}
	}
    return hash;
}

int main() {
	uint32_t Q;
	cin >> Q;
	for (int i = 0; i < Q; ++i) {
		ull d;
		cin >> d;
		cout << dehash(d) << "\n";
	}
	return 0;
}
\end{lstlisting}


\newpage
\textbf{{\large Задача 11 - Стулья мастера Гамбса}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Eurasia/11.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Для решения данной задачи мы отсортируем стулья по стоимости, а затем будем набирать стулья начиная с самых дешевых. Если находим стул, который не можем купить, то завершаем выполнение, так как дальше не будет стульев которые мы сможем купить. Сложность алгоритма $O(N^2 * log(N)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <algorithm>
#include <fstream>
#include <vector>

using namespace std;

bool pairMinMax(const pair<int, int> &a, const pair<int, int> &b) {
	return a.second < b.second;
}


int main() {

	ifstream in("input.txt");
	ofstream out("output.txt");


	int N;
	long long S;

	in >> N >> S;

	vector <pair <int, int> > element(N);
	vector <bool> bought(N+1, false);

	pair <int, int> temp;
	for (int i = 0; i < N; i++) {
		in >> temp.first >> temp.second;
		element[i] = temp;
	}

	sort(element.begin(), element.end(), pairMinMax);

	int count = 0;
	for (int i = 0; i < N; i++) {
		if (element[i].second > S) {
			break;
		}
		if (element[i].second <= S && bought[element[i].first] == false) {
			S -= element[i].second;
			bought[element[i].first] = true;
			count++;
		}
	}

	out << count << endl;
	
	in.close();
	out.close();

	return 0;
}
\end{lstlisting}


\newpage
\textbf{{\large Задача 12 - Эрудит}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Eurasia/12_1.png}\\ [1cm]
\includegraphics[width=0.9\textwidth]{OC_Eurasia/12_2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

\textcolor{red}{\Huge{АНТОН ????}}. \\

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
use bigint;
my @cmap = qw(  rwwgwwwrwwwgwwr
				wbwwwywwwywwwbw
				wwbwwwgwgwwwbww
				gwwbwwwgwwwbwwg
				wwwwbwwwwwbwwww
				wywwwwwwwwwwwyw
				wwgwwwgwgwwwgww
				rwwgwwwswwwgwwr
				wwgwwwgwgwwwgww
				wywwwwwwwwwwwyw
				wwwwbwwwwwbwwww
				gwwbwwwgwwwbwwg
				wwbwwwgwgwwwbww
				wbwwwywwwywwwbw
				rwwgwwwrwwwgwwr);
my @map;
for (my $i = 0; $i < 16; ++$i) {
	for (my $j = 0; $j < 16; ++$j) {
		$map[$i][$j] = 0;
	}
}
my @alp = (1,3,2,3,2,1,5,5,1,2,2,2,2,1,1,2,2,2,2,3,10,5,10,5,10,10,10,5,5,10,10,3);

my %cl = 
   (w => 1,
    s => 1,
    g => 2,
    y => 3,
    b => 1,
    r => 1);

my %cw = 
   (w => 1,
    s => 1,
    g => 1,
    y => 1,
    b => 2,
    r => 3);

sub getColor {
	my ($x, $y) = @_;
	substr $cmap[$y-1], $x-1, 1;
}
my $str;
$str = <ARGV>;
chomp $str;
my ($n, $m) = split(" ", $str);
my @scores;
for (my $i = 0; $i < $n; ++$i) {
	$scores[$i] = 0;
}
for (my $si = 0; $si < $m; ++$si) {
	my $str = <ARGV>;
	chomp $str;
	my $w = $str;
	my $count = 0;
	my $score = 0;
	for (my $i = 0; $i < $w; ++$i) {
		$str = <ARGV>;
		chomp $str;
		my @A = split(" ", $str);
		my $l = shift @A;
		my $dir = shift @A;
		my $x = shift @A;
		my $y = shift @A;
		my $scoreL = 0;
		my $scoreW = 1;
		for my $char (@A) {
			my $color = getColor($x, $y);
			unless ($map[$x][$y]) {
				$map[$x][$y] = 1;
				++$count;
			}

			$scoreL += $cl{$color} * $alp[$char-1];
			$scoreW *= $cw{$color};
			if ($dir eq 'v') {
				++$y;
			}
			else {
				++$x;
			}
		}
		$score += $scoreW * $scoreL;
	}
	if ($count == 7) {
		$score += 15;
	}
	$scores[$si%$n] += $score;
}
print join("\n", @scores), "\n";
\end{lstlisting}





%----------------------------------------------------------------------------------------
%
%	OpenCup GrandPrix of SPb
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{OpenCup GrandPrix of SPb (2 solved) + (алгоритм в E)}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_SPB/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10324}}}

\newpage
\textbf{{\large Задача E - Следующее разбиение}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_SPB/E.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

\textcolor{red}{\Huge{АНТОН ????}}. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>using namespace std;
bool pairMinMax(const pair<int, int> &a, const pair<int, int> &b) {
	return a.second < b.second;
}
int main() {
	int input;
	ifstream in("next-partition.in");
	ofstream out("next-partition.out");
	int K;
	in >> K;
	vector <int> A(K);
	int N = 0;
	int temp;
	for (int i = 0; i < K; i++) {
		in >> temp;
		A[i] = temp;
		N += temp;
	}
	bool flag1 = false;
	bool flag2 = false;
	int sum = 0;
	sort(A.begin(), A.end());
	int iMarked = 0;
	for (int i = 0; i < K - 1; i++) {
		sum += A[i];
		if (A[i + 1] - A[i] >= 2) {
			iMarked = i + 1;
			A[i + 1]--;
			sum++;
			flag1 = true;
			break;
		}
	}
	if (!flag1) {
		for (int i = 0; i < K - 2; i++) {
			for (int j = i + 2; j < K; j++) {
				if (A[i] + 1 > A[i + 1]) {
					break;
				}
				if (A[j] - A[i] > 2) {
					break;
				}
				if (A[j] - A[i] == 2 && A[j] - 1 >= A[j - 1]) {
					A[j]--;
					A[i]++;
					flag2 = true;
					break;
				}
			}
		}
	}
	if (flag1) {
		sum -= iMarked;
		for (int i = iMarked - 1; i >= 0; i--) {
			if (sum > 0) {
				temp = A[iMarked];
				if (sum+1 >= temp) {
					A[i] = temp;
					sum = sum - temp + 1;
				}
				else {
					A[i] = sum + 1;
					sum = 0;
				}
			}
			else A[i] = 1;
		}
		out << K << endl;
		for (int i = K - 1; i >= 0; i--) {
			out << A[i] << " ";
		}
	}
	else if (flag2) {
		out << K << endl;
		for (int i = K - 1; i >= 0; i--) {
			out << A[i] << " ";
		}
	} else {
		out << -1;
	}
	in.close();
	out.close();
	return 0;
}
\end{lstlisting}


\newpage
\textbf{{\large Задача G - Головоломка Обмен}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_SPB/G.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Так как доска всегда имеет размеры 4х4, то задачу можно решить полным перебором. Сначала перебором находим все неправильные пары чисел, а затем начинаем исправлять пары переставляя строки, пока доска не станет правильной.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <sstream>
#include <vector>
#include <fstream>

using namespace std;

bool desk_is_correct(int desk[4][4])
{
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            int targer_i = (desk[i][j] - 1) / 4;
            int targer_j = (desk[i][j] - 1) % 4;
            if (i != targer_i || j != targer_j) {
                return false;
            }
        }
    }
    return true;
}

char character_for_num(int num)
{
    return char('a' + num);
}

int main(int argc, const char * argv[])
{
    stringstream ss;
    
    ifstream in("puzzle-swap.in");
    ofstream out("puzzle-swap.out");
    
    int desk[4][4] = {0};
    
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            in >> desk[i][j];
        }
    }
    
    int moves = 0;
    vector<string> log;
    
    // find all wrong pairs
    for (int i1 = 0; i1 < 4; i1++) {
        for (int j1 = 0; j1 < 4; j1++) {
            for (int i2 = 0; i2 < 4; i2++) {
                for (int j2 = 0; j2 < 4; j2++) {
                    if (i1 != i2 || j1 != j2) {
                        int targer_i1 = (desk[i1][j1] - 1) / 4;
                        int targer_j1 = (desk[i1][j1] - 1) % 4;
                        int targer_i2 = (desk[i2][j2] - 1) / 4;
                        int targer_j2 = (desk[i2][j2] - 1) % 4;
                        if (targer_i1 == i2 && targer_j1 == j2 &&
                            targer_i2 == i1 && targer_j2 == j1) {
                            moves++;
                            swap(desk[i1][j1], desk[i2][j2]);
                            ss << character_for_num(i1) << j1 + 1 << "-" << character_for_num(i2) << j2 + 1 << endl;
                            string s;
                            ss >> s;
                            log.push_back(s);
                        }
                    }
                }
            }
        }
    }
    
    while (!desk_is_correct(desk)) {
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                int targer_i = (desk[i][j] - 1) / 4;
                int targer_j = (desk[i][j] - 1) % 4;
                if (i != targer_i || j != targer_j) {
                    moves++;
                    swap(desk[i][j], desk[targer_i][targer_j]);
                    ss << character_for_num(i) << j + 1 << "-" << character_for_num(targer_i) << targer_j + 1 << endl;
                    string s;
                    ss >> s;
                    log.push_back(s);
                }
            }
        }
    }
    
    out << moves << endl;
    for (size_t i = 0; i < log.size(); i++) {
        out << log[i] << endl;
    }
    
    in.close();
    out.close();
    
    return 0;
}

\end{lstlisting}





%----------------------------------------------------------------------------------------
%
%	ACM 1/4 Final
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{ACM-ICPC Московский четвертьфинал + DONE}

Так как соревнование проводилось в ВШЭ, то турнирная таблица с результатами и исходные коды программ не доступны. \\




%----------------------------------------------------------------------------------------
%
%	OpenCup GrandPrix of Yekaterinburg
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Yekaterinburg (4 solved) + (алгоритм в B)}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_YKB/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10325}}}

\newpage
\textbf{{\large Задача B - Black Widow}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_YKB/B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

\textcolor{red}{\Huge{АНТОН ????}}. \\

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <set>
#include <vector>
using namespace std;
#define ll long long
#define ull unsigned long long

int main() {
	ull n;
	cin >> n;
	set<ull> v;
	vector<ull> m;
	ull maxV = 0;
	ull a = 1;
	for (int i = 0; i < n; ++i) {
		ull d;
		cin >> d;
		if (d > maxV)
			maxV = d;
		v.insert(d);
		m.push_back(d);
	}
	bool f = 1;
	while (1) {
		++a;
		bool f = 1;
		for (int i = 0; i < n; ++i) {
			if (m[i] >= a && m[i]%a == 0) {
				f = 0;
				break;
			}
		}
		if (f) {
			break;
		}
	}
	while (1) {
		f = 1;
		for (ull x = 0; x < maxV+1; x += a) {
			if (v.find(x) != v.end()) {
				f = 0;
				break;
			}
		}
		if (f) {
			cout << a << endl;
			break;
		}
		while (1) {
			++a;
			bool f = 1;
			for (int i = 0; i < n; ++i) {
				if (m[i] >= a && m[i]%a == 0) {
					f = 0;
					break;
				}
			}
			if (f) {
				break;
			}
		}
	}
	return 0;
}
\end{lstlisting}


\newpage
\textbf{{\large Задача D - Dr. Banner}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_YKB/D.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Для решения этой задачи нам нужно знать префиксную сумму по времени на отрезке. Мы можем вычислить вручную несколько первых значений, по которым потом сможешь получить любое значение, так как все они высчитываются на основе предыдущих. Сложность алгоритма $O(N)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Ruby]
n = gets.to_i
m = (1e+9 + 7).to_i

amount = Array.new(1e+5 + 1)
sum_for_pos = Array.new(1e+5 + 1)

k = 5

amount[1] = 1
amount[2] = 2
amount[3] = 2
amount[4] = 4

sum_for_pos[1] = 1
sum_for_pos[2] = 3
sum_for_pos[3] = 5
sum_for_pos[4] = 9

while k <= n do
    max_next_k = k / 2
    amount[k] = (1 + sum_for_pos[max_next_k])
    sum_for_pos[k] = sum_for_pos[k - 1] + amount[k]
    k += 1
end

answer = (amount[n] % m)

puts answer
\end{lstlisting}



\newpage
\textbf{{\large Задача G - Groot}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_YKB/G.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно посчитать количество восклицательных знаков во входной строке и вывести слово Wow, в котором столько же букв $o$, сколько знаков в строке. Если в строке нет ни одного знака, то вывести Pffff. Сложность $O(1)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
my $str =  <>;
my @a = $str =~ /\!/g;
my $n = scalar(@a);
if ($n == 0) {
	print "Pfff";
}
else {
	print "W"."o"x$n."w";
}
\end{lstlisting}


\newpage
\textbf{{\large Задача L - Loki and Forks}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_YKB/L.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Чтобы посчитать количество уникальных наборов нужно просто отсортировать все значения количества зубьев в наборах, затем построить из этих чисел строки путем конкатенирования и посчитать количество уникальных строк. Сложность $O(N * log(N))$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
my %h;
while (my $str = <>) {
	chomp $str;
	++$h{join "", sort {$a <=> $b} split " ", $str};
}
print scalar(keys(%h));
\end{lstlisting}







%----------------------------------------------------------------------------------------
%
%	OpenCup GP of Siberia
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Siberia (6 solved) + (алгоритм в B, K)}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Siberia/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10281}}}

\newpage
\textbf{{\large Задача А - Detect a Mood}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Siberia/A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно посчитать количество открывающих и закрывающих скобок, а затем найти их разность. Это и будет ответом. Сложность $O(N)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
my $s = <>;
chomp $s;
while ($s =~ s/\(\)//) {}
my $n = length($s);
$s =~ s/\)//g;
my $rn = length($s);
print $n - 2*$rn;
\end{lstlisting}


\newpage
\textbf{{\large Задача B - Painting Tracks}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Siberia/B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

\textcolor{red}{\Huge{АНТОН ????}}. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>
#include <set>

#define LL long long
#define ULL  unsigned long long


using namespace std;

ULL myAbs(ULL a, ULL b) {
	if(a > b) {
		return a - b;
	} else {
		return b - a + 1;
	}
}

int main() {

	int temp;
	ULL N, M;
	cin >> N >> M;
	if(N == M) {
		cout << 6 << endl;
		return 0;
	}
	else {
		ULL answ = 3;
		for(int i = 0; i < myAbs(N, M); i++) {
			answ *= 2;
		}
		cout << answ << endl;
	}

	//cin >> temp;
	
	return 0;

}
\end{lstlisting}


\newpage
\textbf{{\large Задача D - Match of the Giants}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Siberia/D.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно найти максимально возможный счет для каждой команды. Для этого отсортируем значения каждой команды по убыванию и для каждой команды найдем значение в противоположной команде, которое даст максимальный выигрыш. Сложность $O(N * log(N))$. \\

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

int main(int argc, const char * argv[]) {
    
    int n;
    cin >> n;
    
    vector<int> gtu(n);
    vector<int> tsu(n);
    
    int val;
    
    for (int i = 0; i < n; i++) {
        cin >> val;
        gtu[i] = val;
    }
    
    for (int i = 0; i < n; i++) {
        cin >> val;
        tsu[i] = val;
    }
    
    sort(gtu.begin(), gtu.end(), greater<int>());
    sort(tsu.begin(), tsu.end(), greater<int>());
    
    int gtu_score = 0;
    int tsu_score = 0;
    
    vector<int> tsu_search = tsu;
    
    int next_start_pos = 0;
    
    for (int i = 0; i < n; i++) {
        bool found = false;
        for (int j = next_start_pos; j < n; j++) {
            if (gtu[i] > tsu_search[j]) {
                gtu_score++;
                tsu_search[j] = INT_MAX;
                found = true;
                next_start_pos = j + 1;
                break;
            }
        }
        if (!found) {
            break;
        }
    }
    
    next_start_pos = 0;
    
    for (int i = 0; i < n; i++) {
        bool found = false;
        for (int j = next_start_pos; j < n; j++) {
            if (tsu[i] > gtu[j]) {
                tsu_score++;
                gtu[j] = INT_MAX;
                found = true;
                next_start_pos = j + 1;
                break;
            }
        }
        if (!found) {
            break;
        }
    }
    
    cout << gtu_score << " " << tsu_score << endl;
    
    return 0;
}

\end{lstlisting}


\newpage
\textbf{{\large Задача G - Files list}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Siberia/G.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно найти количество уникальных расширений файлов. Для этого каждое расширение в строке будем заносить в хеш-таблицу и запоминать количество вхождений. Сложность $O(N * log(N))$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
<>;
my %h;
my $i;
my @keys;
while (my $s = <>) {
	chomp $s;
	my ($suf) = $s =~ /\.(.+?)$/;
	push @keys, $suf unless exists $h{$suf};
	++$h{$suf};
}
foreach my $key (@keys) {
	print $key, ": ", $h{$key}, "\n";
}
\end{lstlisting}


\newpage
\textbf{{\large Задача K - Hive}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Siberia/K.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

\textcolor{red}{\Huge{АНТОН ????}}. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
my ($n, $x0, $y0) = split " ", <>;
for (my $i = 0; $i < $n; ++$i) {
	my ($x, $y) = split " ", <>;
	print $x0+$y-$y0+$x-$x0, " ", $y0-$x+$x0, "\n";
}
\end{lstlisting}


\newpage
\textbf{{\large Задача L - Side effect}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Siberia/L.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Эту задачу можно решить поиском в ширину в графе вызовов функций, чтобы найти все зависимости в вызовах. Сложность алгоритма $O(N + M)$. \\

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
int main(int argc, const char * argv[]) {
    int n, k, m;
    cin >> n >> k >> m;
    vector< vector<int> > g(n + 1, vector<int>());
    vector<bool> side_effect(n + 1, false);
    int func_num;
    for (int i = 0; i < k; i++) {
        cin >> func_num;
        side_effect[func_num] = true;
    }
    int a, b;
    int count = k;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        g[b].push_back(a);
        if (!side_effect[a] && side_effect[b]) {
            side_effect[a] = true;
            count++;
            queue<int> q;
            q.push(a);
            vector<bool> used(n + 1);
            used[a] = true;
            while (!q.empty()) {
                int v = q.front();
                q.pop();
                for (size_t i = 0; i < g[v].size(); ++i) {
                    int to = g[v][i];
                    if (!used[to]) {
                        used[to] = true;
                        if (!side_effect[to]) {
                            side_effect[to] = true;
                            count++;
                            q.push(to);
                        }
                        
                    }
                }
            }
        }
        cout << count << endl;
    }
    return 0;
}
\end{lstlisting}








%----------------------------------------------------------------------------------------
%
%	OpenCup GrandPrix of Europe
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Europe (3 solved) + DONE}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Europe/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10327}}}

\newpage
\textbf{{\large Задача A - ASCII Addition}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Europe/A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Задача просто на реализацию. \\

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
my %digits = (
	"xxxxx".
	"x...x".
	"x...x".
	"x...x".
	"x...x".
	"x...x".
	"xxxxx" => 0,
	"....x".
	"....x".
	"....x".
	"....x".
	"....x".
	"....x".
	"....x" => 1,

	"xxxxx".
	"....x".
	"....x".
	"xxxxx".
	"x....".
	"x....".
	"xxxxx" => 2,

	"xxxxx".
	"....x".
	"....x".
	"xxxxx".
	"....x".
	"....x".
	"xxxxx" => 3,

	"x...x".
	"x...x".
	"x...x".
	"xxxxx".
	"....x".
	"....x".
	"....x" => 4,

	"xxxxx".
	"x....".
	"x....".
	"xxxxx".
	"....x".
	"....x".
	"xxxxx" => 5,

	"xxxxx".
	"x....".
	"x....".
	"xxxxx".
	"x...x".
	"x...x".
	"xxxxx" => 6,

	"xxxxx".
	"....x".
	"....x".
	"....x".
	"....x".
	"....x".
	"....x" => 7,

	"xxxxx".
	"x...x".
	"x...x".
	"xxxxx".
	"x...x".
	"x...x".
	"xxxxx" => 8,

	"xxxxx".
	"x...x".
	"x...x".
	"xxxxx".
	"....x".
	"....x".
	"xxxxx" => 9,

	".....".
	"..x..".
	"..x..".
	"xxxxx".
	"..x..".
	"..x..".
	"....." => "+"
	);
my %dig;
foreach my $key (keys %digits) {
	$dig{$digits{$key}} = $key;
}
my @screen;
for (my $i = 0; $i < 7; ++$i) {
	my $str = <>;
	chomp $str;
	my $n = length($str)+1;
	my $dig_cnt = $n/6;
	for (my $j = 0; $j < $dig_cnt; ++$j) {
		my $a = substr substr($str, $j*6, 6), 0, 5;
		$screen[$j] .= $a;
	}
}
my $expr = "";
foreach my $s (@screen) {
	$expr .= $digits{$s};
}
my $res = eval $expr;
for (my $i = 0; $i < 7; ++$i) {
	my $str = "";
	foreach my $d (split "", $res) {
		my $a = substr $dig{$d}, $i*5, 5;
		$str .= $a.".";
	}
	chop $str;
	print $str, "\n";
}
\end{lstlisting}


\newpage
\textbf{{\large Задача C - Counting Cities}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Europe/C.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче надо посчитать количество уникальных посещенных городов. Для этого каждую входную строку будем помещать в std::set, а потом просто выведем размер множества. \\

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <set>
#include <string>

using namespace std;

int main(int argc, const char * argv[]) {
    
    int t;
    cin >> t;
    set<string> s;
    while (t--) {
        int n;
        cin >> n;
        string name;
        for (int i = 0; i < n; i++) {
            cin >> name;
            s.insert(name);
        }
        cout << s.size() << endl;
        s.clear();
    }
    
    return 0;
}

\end{lstlisting}


\newpage
\textbf{{\large Задача E - Electoral Estimations}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Europe/E.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Для решения этой задачи нужно подсчитать голоса для каждого кандидата, отсортировать их и затем найти отношения количества голосов за победителя к остальным, чтобы определить, является он абсолютным победителем или нет. \\

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>
#include <vector>
typedef struct {
    int number;
    int votes;
} Person;
bool cmp(const Person &a, const Person &b) {
    return a.votes > b.votes;
}
using namespace std;
int main(int argc, const char * argv[]) {
    int t;
    cin >> t; 
    while (t--) {
        int n;
        cin >> n;
        int total_votes = 0;
        vector<Person> persons(n);
        for (int i = 0; i < n; i++) {
            persons[i].number = i + 1;
            cin >> persons[i].votes;
            total_votes += persons[i].votes;
        }
        sort(persons.begin(), persons.end(), cmp);
        int top_votes = persons[0].votes;
        int half_votes = total_votes / 2;
        if (t == 1) {
            cout << " " << endl;
        }
        if (top_votes > half_votes) {
            if (persons[1].votes != top_votes) {
                cout << "Victory " << persons[0].number << endl;
            } else {
                cout << "Tie" << endl;
            }
        } else {
            if (persons[1].votes != top_votes) {
                cout << "Leader " << persons[0].number << endl;
            } else {
                cout << "Tie" << endl;
            }
        }
    }
    return 0;
}
\end{lstlisting}






%----------------------------------------------------------------------------------------
%
%	OpenCup GrandPrix of Peterhof
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Peterhof (4 solved) + (алгоритм в A, E, G)}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Peterhof/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10328}}}

\newpage
\textbf{{\large Задача A - (a, b)-башня}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Peterhof/A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

\textcolor{red}{\Huge{АНТОН ????}}. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Ruby]
#!/usr/bin/env ruby
def func(l, r)
  if l < r
    (l ** func(l+1, r))%10
  else
    r%10
  end
end
a, b = gets.split.map {|x| x.to_i}
puts func(a,b)

\end{lstlisting}


\newpage
\textbf{{\large Задача C - Отношение эквивалентности}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Peterhof/C.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Задача на реализацию. Необходимо найти классы эквивалентности. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Ruby]
n = gets.to_i

data = Array.new

for i in 0...n
    s = gets.chomp
    data.push(s)
end

data.each do |s|
    begin
        s_copy = s.clone
        s.gsub!(/0{2}/,'')
        s.gsub!(/1{3}/,'')
    end until s == s_copy
end

h = Hash.new()

data.each_index do |i|
    s = data[i]
    if h[s] == nil
        h[s] = Array.new
    end
    h[s].push(i + 1)
end

res = Array.new

h.each_value do |v|
    res.push(v)
end

res.sort! do |a, b|
    a.first <=> b.first
end

puts "#{res.size}"

res.each do |l|
    l.each do |x|
        print "#{x} "
    end
    puts
end

\end{lstlisting}

\newpage
\textbf{{\large Задача E - Идеальная фотография}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Peterhof/E.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

\textcolor{red}{\Huge{АНТОН ????}}. \\

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Ruby]
#!/usr/bin/env ruby
def calc_sum(m, i)
  s = 0
  for a in m do
    s += Math.sqrt((a-i)*(a-i) + 1)
    i += 1
  end
  return s
end
n = gets.to_i
r = gets.split.map{|x| x.to_i}
c = gets.split.map{|x| x.to_i}
m = (r + c).sort
x = 0
step = 1000000
sum_curr = calc_sum(m, x)
sum_prev = sum_curr + 1
sign = 1
x += step
while ((sum_prev-sum_curr).abs > 0.0000000001)
  sum_prev = sum_curr
  sum_curr = calc_sum(m, x)
  if sum_curr > sum_prev && sign == 1
    sign = -1
    step /= 2.0
    sign_counter = 0
  elsif sum_curr > sum_prev && sign == -1
     sign = 1
     step /= 2.0
     sign_counter = 0
  end
  x += step*sign
end
puts sum_curr

\end{lstlisting}

\newpage
\textbf{{\large Задача G - Случайные тоннели}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Peterhof/G.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

\textcolor{red}{\Huge{АНТОН ????}}. \\

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Ruby]
#!/usr/bin/env ruby
def send_cmd(cmd)
  puts cmd
  STDOUT.flush
end
a = 1
while (true) do
  send_cmd a
  case gets
  when /yes/
    exit if a == 1
    a = 1
  when /no/
    a = rand(1<<31)
  end
end

\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Codeforces ACM Южный четвертьфинал
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{Codeforces ACM-ICPC Южный четвертьфинал}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{CT_ACM_WEST/CT_ACM_WEST_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/gym/100513}}}

\newpage
\textbf{{\large Задача D - Data Center}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_ACM_WEST/CT_ACM_WEST_D.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Сначала отсортируем сервера по объему памяти. Наберем необходимое количество серверов и сравним набранную память с минимальным объемом. Если разница равна $0$, то ответ найден. Иначе будем пытаться поменять сервера с высоким напряжением на сервера с низким напряжением. Сложность $O(n^2)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <algorithm>
#include <fstream>

using namespace std;

typedef struct {
    LL num;
    ULL cap;
    short low;
} server;

bool cmp_low(const server &a, const server &b) {
    return a.low > b.low;
}

bool cmp_cap(const server &a, const server &b) {
    if (a.cap == b.cap) return a.low > b.low;
    return a.cap > b.cap;
}

int main() {
    LL n;
    ULL m;
    cin >> n >> m;
    vector<server> s(n);
    for (LL i = 0; i < n; i++) {
        s[i].num = i + 1;
        cin >> s[i].cap;
        cin >> s[i].low;
    }

    sort(s.begin(), s.end(), cmp_cap);
    LL ind = 0;
    ULL curr_cap = 0;
    LL count = 0;

    while (curr_cap < m) {
        curr_cap += s[ind].cap;
        if (s[ind].low) count++;
        ind++;
    }

    ULL rem = curr_cap - m;

    if (rem == 0) {
        cout << ind << " ";
        cout << count << endl;
        for (LL i = 0; i < ind; i++) {
            cout << s[i].num << " ";
        }
        cout << endl;
        return 0;
    }

    for (LL i = ind - 1; i >= 0; i--) {
        if (!s[i].low && rem > 0) {
            bool azaza = false;
            for (LL j = ind; j < n; j++) {
                if (s[j].low && (s[j].cap + rem >= s[i].cap)) {
                    rem -= s[i].cap - s[j].cap;
                    swap(s[i], s[j]);
                    count++;
                    azaza = true;
                    break;
                }
            }
            if (!azaza) break;
        }
        else if (rem == 0) break;
    }

    cout << ind << " " << count << endl;
    for (LL i = 0; i < ind; i++) {
        cout << s[i].num << " ";
    }
    cout << endl;;
	return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача I - Sales in GameStore}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_ACM_WEST/CT_ACM_WEST_I.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Отсортируем цены по возрастанию. Затем будем складывать цены по порядку из возрастания и будем считать количество сложений, пока сумма не станет больше максимальной цены. В ответе выведем значение счётчика сложений. Сложность $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
bool compare(const int &a, const int &b) {
    return a<b;
}
int main(int argc, const char * argv[]) {
    vector<int> p(2001);
    int n;
    cin >> n;
    for(int i=0; i<n; ++i)
        cin >> p[i];
    sort(p.begin(), p.begin()+n);
    int sum = 0;
    int i=0;
    while(i<n-1 && sum+p[i]<=p[n-1])
        sum += p[i++];
    cout << i+1;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача M - Variable Shadowing}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_ACM_WEST/CT_ACM_WEST_M1.png}\\ [1cm]
\includegraphics[width=0.9\textwidth]{CT_ACM_WEST/CT_ACM_WEST_M2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Задачу можно решить с помощью стека и вектора стеков. Предупреждение нужно выводить когда новая переменная пытается попасть в стек, который не пуст, это значит уже была объявлена переменная с таким же именем. Когда появляется закрывающая скобка убираем все до открывающей.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
typedef struct {
    char ch;
    int line;
    int sym;
} var;
int main() {
    int f,n;
    cin >> n;
    vector <stack <var> > all_alph(26);
    stack <var> curr;
    char temp;
    int symbol = 0;
    var to_put;
    temp = cin.get();
    for (int i = 1; i <= n; i++){
        temp = cin.get();
        symbol = 1;
        while(temp != '\n') {
            if(temp == '}') {
                to_put = curr.top();
                curr.pop();
                while (to_put.ch != '{') {
                    all_alph[to_put.ch - 97].pop();
                    to_put = curr.top();
                    curr.pop();
                }
            }
            else if(temp == '{') {
                to_put.ch = temp;
                to_put.sym = symbol;
                to_put.line = i;
                curr.push(to_put);
            }
            else if (temp != ' '){
                to_put.sym = symbol;
                to_put.line = i;
                to_put.ch = temp;
                curr.push(to_put);
                if(all_alph[temp - 97].size() != 0)
                    cout << to_put.line << ":" << to_put.sym
                    << ": warning: shadowed declaration of "<< to_put.ch
                    << ", the shadowed position is " << all_alph[temp - 97].top().line
                    << ":" << all_alph[temp - 97].top().sym << endl;
                all_alph[temp - 97].push(to_put);
            }

            temp = cin.get();
            symbol++;
        }
    }
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	ACM 1/4 Final
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{ACM-ICPC Московский четвертьфинал}

Так как соревнование проводилось в МГУ, то турнирная таблица с результатами и исходные коды программ не доступны. \\



%----------------------------------------------------------------------------------------
%
%	Codeforces Training S02E07
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{Codeforces Training S02E07}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{CT_S02E07/CT_S02E07_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/gym/100523}}}

\newpage
\textbf{{\large Задача C - Will It Stop?}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_S02E07/CT_S02E07_C.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Делим число n на 2 до тех пор пока оно не перестанет делиться на 2. Если получившееся число равно единице, то выводим $TAK$, если нет, то $NIE$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
int main()
{
    unsigned long long a;
    cin >> a;
    while(!(a%2))a/=2;
    if(a==1)
        cout << "TAK";
    else
        cout << "NIE";
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача H - Afternoon Tea}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_S02E07/CT_S02E07_H.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Создадим две переменные одну для чая, другую для молока и будем последовательно, для каждой буквы, добавлять к ним значение зависящее от позиции текущей буквы, и посчитанное по выведенной формуле. Сложность O(n). \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
    int n;
    cin >> n;
    if(n==1)
    {
        cout << "HM";
        return 0;
    }
    cin.get();
    char c;
    long double hDrunked = 0, mDrunked = 0;
    hDrunked = mDrunked = (1-pow(0.5, n))*0.5;
    for(int i=0; i<n-1; ++i)
    {
        c=cin.get();
        if(c=='H')
            hDrunked += (1-pow(0.5, n-i-1))*0.5;
        else
            mDrunked += (1-pow(0.5, n-i-1))*0.5;
    }
    if(hDrunked>mDrunked)
        cout << "H";
    else if(hDrunked<mDrunked)
        cout << "M";
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Codeforces Crypto Cup
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{Codeforces Crypto Cup 1.0}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{CT_Crypto/CT_Crypto_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/gym/100514}}}

\newpage
\textbf{{\large Задача B - :-P}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_Crypto/CT_Crypto_B.png}\\ [1cm]
\end{center}

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;
int main(int argc, const char * argv[]) {
    char str[100001];
    long p, len;
    while((str[len]=cin.get())!='\n') ++len;
    str[len] = '\0';
    cin >> p;
    vector< vector <char> > v(p);
    long vSize = len/p, r = len%p;
    for(long i=r; i<p; ++i) {
        v[i].resize(vSize);
    }
    for(long i=0; i<r; ++i) {
        v[i].resize(vSize+1);
    }
    for(long i=0, k=0; i<p; ++i) {
        for(long j=0; j<v[i].size(); ++j, ++k) {
            v[i][j] = str[k];
        }
    }
    for(long i=0; i<len; ++i) {
        cout.put(v[i%p][i/p]);
    }
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача C - Pgkpxumgs}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_Crypto/CT_Crypto_C.png}\\ [1cm]
\end{center}

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
	char cur, prev;
	cout.put(prev = cin.get());
	while ((cur = cin.get()) != '\n') {
		if ((int)(cur - prev) < 0) cout << (char)(cur - prev + '{');
		else cout << (char)(cur - prev + 'a');
		prev = cur;
 	}
	return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача H - Peace of AmericaReunion}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_Crypto/CT_Crypto_H.png}\\ [1cm]
\end{center}

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
int main() {
	vector<long> v(26);
	long length = 0;
	for (int i = 0; i < 26; i++) {
		cin >> v[i];
		length += v[i];
	}
	vector<char> answer(length);
	long pos;
	int nextSymb = -1;
	for (int i = 0; i < 26; i++) {
		if (v[i]) {
			nextSymb = i;
			break;
		}
	}
	for (long i = 0; i < length; i++) {
		cin >> pos;
		if (!v[nextSymb]) {
			for (int i = nextSymb; i < 26; i++) {
				if (v[i]) {
					nextSymb = i;
					break;
				}
			}
		}
		answer[--pos] = (char)(nextSymb + 'a');
		v[nextSymb]--;
	}
	for (auto n : answer) cout << n;
	return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача I - Peace of AmericanPie}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_Crypto/CT_Crypto_I.png}\\ [1cm]
\end{center}

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
int main() {
	int byte = 0;
	int spow = 256;
	int collected = 0;
	char currentBit;
	while ((currentBit = cin.get()) != '\n') {
		cin.unget();
		while (collected < 8) {
			currentBit = cin.get();
			byte += (currentBit - '0') * spow;
			spow /= 2;
			collected++;
		}
		cout << (char)(byte / 2);
		byte = 0;
		spow = 256;
		collected = 0;
	}
	return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача J - Common}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_Crypto/CT_Crypto_J.png}\\ [1cm]
\end{center}

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
int main() {
	char t;
	while ((t = cin.get()) != '\n') {
		switch (t) {
			case 'a':
				cout << "n";
				break;
			case 'b':
				cout << "h";
				break;
			case 'c':
				cout << "r";
				break;
			case 'd':
				cout << "x";
				break;
			case 'e':
				cout << "k";
				break;
			case 'f':
				cout << "e";
				break;
			case 'g':
				cout << "y";
				break;
			case 'h':
				cout << "o";
				break;
			case 'i':
				cout << "q";
				break;
			case 'j':
				cout << "m";
				break;
			case 'k':
				cout << "j";
				break;
			case 'l':
				cout << "b";
				break;
			case 'm':
				cout << "d";
				break;
			case 'n':
				cout << "u";
				break;
			case 'o':
				cout << "v";
				break;
			case 'p':
				cout << "a";
				break;
			case 'q':
				cout << "p";
				break;
			case 'r':
				cout << "w";
				break;
			case 's':
				cout << "g";
				break;
			case 't':
				cout << "z";
				break;
			case 'u':
				cout << "f";
				break;
			case 'v':
				cout << "i";
				break;
			case 'w':
				cout << "c";
				break;
			case 'x':
				cout << "s";
				break;
			case 'y':
				cout << "t";
				break;
			case 'z':
				cout << "l";
				break;
		}
	}
	return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача M - oPlus}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_Crypto/CT_Crypto_M.png}\\ [1cm]
\end{center}

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
int main() {
	long n;
	int curr, sum;
	cin >> n;
	for (long i = 0; i < n; i++) {
		cin >> curr;
		if (curr % 2) sum = 400;
		else sum = 398;
		cout << (char)(sum - curr - 112);
	}
	return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача N - tirnaoeumPt}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_Crypto/CT_Crypto_N.png}\\ [1cm]
\end{center}

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;

int main()
{
    int m[] = {0, 1, 16, 17, 8, 9, 24, 25, 2, 3, 18, 19, 10, 11, 22, 23, 4,  5,  20, 21, 12, 13, 22, 23, 6,  7,  22, 23, 14, 15};
    int n, d;
    cin >> n;
    for(int i=0; i<n; ++i)
    {
        cin >> d;
        cout.put(m[d]+'a');
    }
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача Q - Peace of bzjd}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_Crypto/CT_Crypto_Q.png}\\ [1cm]
\end{center}

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>

using namespace std;

int main()
{
    char temp;
    temp = cin.get();
    while (temp != '\n' && temp != EOF) {
        if (temp == 'z')
            temp = 'a';
        else temp++;
        cout << temp;
        temp = cin.get();
    }
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача R - 6227020800}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_Crypto/CT_Crypto_R.png}\\ [1cm]
\end{center}

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <algorithm>
#include <deque>
#include <cstdio>
using namespace std;
void p(string s) {
	cout << s << endl;
}
int gcd(int a, int b){
    if (b == 0)
        return a;
    return gcd(b, a%b);
}
int main() {
	char t;
	while ((t = cin.get()) != '\n') {
		t -= 13;
		if (t < 'a') {
			cout << (char)('z' - ('a' - t) + 1);
		}
		else {
			cout << t;
		}
	}
	return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	OpenCup GP of Siberia
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Siberia}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Siberia/OC_Siberia_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10282}}}

\newpage
\textbf{{\large Задача 12 - Construction of Chand Baori}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Siberia/OC_Siberia_12.png}\\ [1cm]
\end{center}
\newpage

\textbf{{\large Алгоритм}}

Если $n! > m$, то вывести $Harshat Mata$, если нет, то $Nope$. Сложность $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;
#define ULL unsigned long long
int main(int argc, const char * argv[]) {
    ULL n, m;
    cin >> n >> m;
    ULL res = 1;
    for(int i=2; i<=n*2; i+=2)
    {
        res *= i;
    }
    if(res<m)
        cout << "Nope";
    else
        cout << "Harshat Mata";
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача 13 - Sum}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Siberia/OC_Siberia_13.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Для того, чтобы подсчитать требуемую сумму можно воспользоваться рекуррентной формулой $a_i = (A * a_{i-1}) \; mod \; P$, где $i \in [2; K]$ и $a_{1} = 1$. Сложность $O(K)$. \\


\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <fstream>
#include <cmath>
#include <vector>
using namespace std;
#define ULL unsigned long long
#define LL long long
int main(int argc, const char * argv[]) {
    ifstream in("input.txt");
    ofstream out("output.txt");
    ULL a, k, p;
    cin >> a >> k >> p;
    ULL sum = 0, prev = 1;
    for(ULL i = 0; i<k; ++i)
    {
        prev = (prev*a)%p;
        sum += prev;
    }
    cout << sum;
    out.close();
    in.close();
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача 14 - Coinquerors}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Siberia/OC_Siberia_14_1.png}\\ [1cm]
\includegraphics[width=0.9\textwidth]{OC_Siberia/OC_Siberia_14_2.png}\\ [1cm]
\end{center}
\newpage

\textbf{{\large Алгоритм}}

Просто подсчитываем количество пересечений у каждой окружности с остальными и находим ту, у которой это количество максимально. Сложность $O(n^2)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <fstream>
#include <cmath>
#include <vector>
using namespace std;
#define ULL unsigned long long
#define LL long long
#define eps 0.0001
struct player
{
    char name[256];
    LL x, y, r;
};
int main(int argc, const char * argv[]) {
    ifstream in("input.txt");
    ofstream out("output.txt");
    ULL T;
    in >> T;
    double pi81 = M_PI/81, pi2 = M_PI*2;
    for(ULL TT = 0; TT<T; ++TT)
    {
        ULL n;
        in >> n;
        vector<player> pl(n);
        for(int i=0; i<n; ++i)
        {
            in >> pl[i].name >> pl[i].x >> pl[i].y >> pl[i].r;
        }
        ULL maxInd = -1, max = 0, forTie = -1;
        for(int i=0; i<n; ++i)
        {
            ULL count = 0;
            LL rr = pl[i].r*pl[i].r;
            for(int j=0; j<n; ++j)
            {
                for(double pi = 0; pi<=pi2; pi += pi81)
                {
                    double x = (pl[j].r-eps)*cos(pi);
                    double y = (pl[j].r-eps)*sin(pi);
                    if((pl[j].x-pl[i].x+x)*(pl[j].x-pl[i].x+x)+(pl[j].y-pl[i].y+y)*(pl[j].y-pl[i].y+y)<=rr)
                    {
                        ++count;
                        break;
                    }
                }
            }
            if(count > max)
            {
                max = count;
                maxInd = i;
                forTie = -1;
            }
            else if(count == max)
            {
                max = count;
                forTie = maxInd;
                maxInd = i;
            }
        }
        if(maxInd == -1 || forTie != -1)
            out << "TIE" << '\n';
        else
            out << pl[maxInd].name << '\n';
    }
    out.close();
    in.close();
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Codeforces Training S02E08
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{Codeforces Training S02E08}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{CT_S02E08/CT_S02E08_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/gym/100526}}}

\newpage
\textbf{{\large Задача G - Growling Gears}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_S02E08/CT_S02E08_G1.png}\\ [1cm]
\includegraphics[width=0.9\textwidth]{CT_S02E08/CT_S02E08_G2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В задаче нужно найти передачу с максимальной скоростью вращения. Для этого мы будем применять формулу $(b * b) / (4 * a) + c$ для каждой передачи. Сложность $O(n^2)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <algorithm>

#include <fstream>

using namespace std;

int main() {
    int k;
    cin >> k;
    int n, a, b, c;
    double max_T = -1000000;
    int max_T_num;
    double temp;

    for(int i = 0; i < k; i++) {
        cin >> n;
        for(int j = 1; j <= n; j++) {
            cin >> a >> b >> c;
            temp = (b * b) / (4 * a) + c;
            if(temp > max_T) {
                max_T = temp;
                max_T_num = j;
            }
        }
        cout << max_T_num << endl;
        max_T = -1000000;
    }
	int q;
	cin >> q;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача J - Jury Jeopardy}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_S02E08/CT_S02E08_J1.png}\\ [1cm]
\includegraphics[width=0.9\textwidth]{CT_S02E08/CT_S02E08_J2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Создаём матрицу, изначально заполненную решётками. Воспроизводим путь робота согласно входным символам и отмечаем путь точками, в процессе запоминая максимальную и минимальную координаты. Используя найденные граничные координаты, вычисляем размер поля и выводим само поле. Сложность $O(n)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
int main(int argc, const char * argv[]) {
    long T;
    cin >> T;
    cout << T << '\n';
    char map[201][201];
    cin.get();
    while(T--)
    {
        for(long i=0; i<201; ++i)
            for(long j=0; j<201; ++j)
                map[i][j] = '#';
        char c;
        long x, y, minX, minY, maxX, maxY;
        maxX = maxY = minX = minY = x = y = 100;
        int dir = 0;
        while((c=cin.get())!='\n')
        {
            switch(dir)
            {
                case 0:
                    if(c=='R')
                        dir = 3;
                    else if(c=='L')
                        dir = 1;
                    else if(c=='B')
                        dir = 2;
                    break;
                case 1:
                    if(c=='R')
                        dir = 0;
                    else if(c=='L')
                        dir = 2;
                    else if(c=='B')
                        dir = 3;
                    break;
                case 2:
                    if(c=='R')
                        dir = 1;
                    else if(c=='L')
                        dir = 3;
                    else if(c=='B')
                        dir = 0;
                    break;
                case 3:
                    if(c=='R')
                        dir = 2;
                    else if(c=='L')
                        dir = 0;
                    else if(c=='B')
                        dir = 1;
                    break;
            }
            switch(dir)
            {
                case 0:
                    ++x;
                    if(x>maxX)
                        maxX = x;
                    break;
                case 1:
                    --y;
                    if(y<minY)
                        minY = y;
                    break;
                case 2:
                    --x;
                    if(x<minX)
                        minX = x;
                    break;
                case 3:
                    ++y;
                    if(y>maxY)
                        maxY = y;
                    break;
            }
            map[x][y] = '.';
        }
        cout << maxY-minY+3 << ' ' << maxX-minX+2 << '\n';
        for(long i = minY-1; i<=maxY+1; ++i)
        {
            for(long j = minX; j<=maxX+1; ++j)
                cout.put(map[j][i]);
            cout.put('\n');
        }
    }
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Codeforces Training S02E09
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{Codeforces Training S02E09}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{CT_S02E09/CT_S02E09_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/gym/100532}}}

\newpage
\textbf{{\large Задача G - Graveyard}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_S02E09/CT_S02E09_G.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Для того, чтобы решить эту задачу, нужно представить окружность в виде отрезка с длиной $10000$. Разобьём отрезок сначала на $n$ частей и запишем точки в вектор $a$, затем разобьём отрезок на $n+m$ частей и запишем точки в вектор $b$. Найдём пару ближайших точек из векторов $a$ и $b$, расстояние между ними и будет ответом. Сложность $O(n^2+nm)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <queue>
#include <climits>
#include <cctype>
#include <cmath>
#include <fstream>
#include <iomanip>
#define ll long long
#define ull unsigned long long
using namespace std;
int main()
{
    ifstream in("graveyard.in");
    ofstream out("graveyard.out");
    ll n, m;
    in >> n >> m;
    ll nm = n+m;
    vector<double> a(n);
    vector<double> b(nm);
    double s = 0;
    for(ll i=0; i<n; ++i)
    {
        a[i] = s;
        s += 10000.0/n;
    }
    s = 0;
    for(ll i=0; i<nm; ++i)
    {
        b[i] = s;
        s += 10000.0/nm;
    }
    vector<bool> u(nm, 0);
    vector<double> r(n);
    double res = 0;
    for(ll i=0; i<n; ++i)
    {
        double min = 200000.0;
        for(ll j=0; j<nm; ++j)
        {

            if(!u[j] && fabs(a[i]-b[j])<min)
            {
                u[j] = 1;
                min = fabs(a[i]-b[j]);
            }
        }
        res += min;
    }
    out << fixed << setprecision(4) << res;
    in.close();
    out.close();
    return 0;
}
\end{lstlisting}


\newpage
\textbf{{\large Задача J - Java vs C++}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_S02E09/CT_S02E09_J.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Посимвольно считываем и проверяем на признаки $Java$ и $C++$. Если обнаружились оба признака, то выводим ошибку. Если только один, то приводим строку к соответствующему формату. Сложность $O(n)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#define ll long long
#define ull unsigned long long
#define ERROR {out << "Error!"; return 0;}
using namespace std;
int main()
{
    ifstream in("java_c.in");
    ofstream out("java_c.out");
    char c;
    bool java = 0, cpp = 0, us = 0;
    char str[1000];
    ll n=0;
    while(!in.eof() && (c=in.get())!='\n')
    {
        if(in.eof())
            break;
        if(c=='_')
        {
            if(us || !n)
                ERROR
            cpp = 1;
            us = 1;
        }
        else if(isupper(c))
        {
            if(!n)
                ERROR
            java = 1;
            str[n++] = '_';
            str[n++] = tolower(c);
        }
        else if(us)
            str[n++] = toupper(c);
        else
            str[n++] = c;
        if(c!='_')
            us = 0;
        if(java && cpp)
            ERROR
    }
    str[n] = '\0';
    if(n&&!us)
        out << str;
    else
        out << "Error!";
    in.close();
    out.close();
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача K - Kickdown}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_S02E09/CT_S02E09_K.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Для решения этой задачи нужно подвигать шестеренки влево и вправо, проверить совпадение и выбрать ответ с наибольшим совпадением.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <fstream>

bool checkGears1(string master, string driven, int pos) {
    for (int i = 0; pos < master.length() && i < driven.length(); i++) {
        if (master[pos] == driven[i])
            if (master[pos] == '2')
                return false;
        pos++;
    }
    return true;
}

bool checkGears2(string master, string driven, int pos) {
    for (int i = 0; i < master.length() && pos < driven.length(); i++) {
        if (master[i] == driven[pos])
            if (master[i] == '2')
                return false;
        pos++;
    }
    return true;
}

int main() {
	ifstream in("kickdown.in");
    ofstream out("kickdown.out");
    string master, driven;
    in >> master >> driven;
    if (master.length() < driven.length()) swap(master, driven);

    int pos1 = 0;
    while (pos1 < master.length() && !checkGears1(master, driven, pos1)) pos1++;

    int pos2 = 0;
    while (pos2 < master.length() && !checkGears2(master, driven, pos2)) pos2++;

    int d1 = (int)(driven.length() + pos1 - master.length());
    int diff1 = (d1 >= 0) ? d1 : 0;
    int diff2 = pos2;

    if (diff1 < diff2) {
        out << max(master.length(), driven.length() + pos1) << endl;
    }
    else {
        out << master.length() + pos2 << endl;
    }

    in.close();
    out.close();

    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Codeforces Олимпиада школьников НН
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{Codeforces Олимпиада школьников Нижегородской обл.}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{CT_school_nn/CT_school_nn_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/gym/100528}}}

\newpage
\textbf{{\large Задача A - Выравнивание вещественных чисел}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_school_nn/CT_school_nn_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Находим число с максимальным количеством цифр перед точкой. Добавляем к остальным числам спереди решётки чтобы перед точкой количество символов стало равно максимальному. Сложность $O(n)$. \\

\textbf{{\large Исходный код}}
\begin{lstlisting}[language=C]
#include <iostream>
#include <cmath>
#define ll long long
#define ull unsigned long long
using namespace std;
int main()
{
    ll n;
    cin >> n;
    char num[1000][2010];
    int logs[1000];
    ll maxLog = 1;
    cin.get();
    for(ll i=0; i<n; ++i)
    {
        ll j=0;
        logs[i] = 0;
        bool pf = 0;
        while((num[i][j]=cin.get())!='\n')
        {
            if(num[i][j] == '.')
                pf = 1;
            if(!pf)
                ++logs[i];
            ++j;
        }
        num[i][j++] = '\0';
        if(logs[i]>maxLog)
            maxLog = logs[i];
    }
    for(ll i=0; i<n; ++i)
    {
        for(ll j=0; j<maxLog-logs[i]; ++j)
            cout.put('#');
        cout << num[i] << '\n';
    }
    return 0;
}
\end{lstlisting}


\newpage
\textbf{{\large Задача F - Фоторамка}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_school_nn/CT_school_nn_F.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче можно заметить закономерность и предпосчитать ответ, так как всего может быть 20 различных входных данных. Таким образом, сложность составляет $O(1)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
int main() {
    long long m[]={0, 0, 0, 24, 120, 360, 840, 1680, 3024, 5040, 7920, 11880, 17160, 24024, 32760, 43680, 57120, 73440, 93024, 116280};
    int n;
    cin >> n;
    cout << m[n-1];
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача I - Изи}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_school_nn/CT_school_nn_I.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В задаче просто нужно вывести $n - 1$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <queue>
#include <climits>
#include <cctype>
#include <fstream>
#define ll long long
#define ull unsigned long long
using namespace std;
int main()
{
    ll n;
    cin >> n;
    cout << n-1;
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	OpenCup GP of Central Europe
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Central Europe}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Central_Europe/OC_Central_Europe_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10283}}}

\newpage
\textbf{{\large Задача A - Адвокат}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Central_Europe/OC_Central_Europe_A.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Для каждого дня находим встречу с минимальным времение конца и встречу с максимальным временем начала. Если время конца первой встречи меньше времени конца второй, то выведем $TAK$ и номера встреч, если нет, то выведем $NIE$. Сложность $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <fstream>
#include <vector>

using namespace std;

int main()
{
    ll n, m;
    ll a, b, d;
    cin >> n >> m;
    vector< pair<ll, ll> > maxA(m, make_pair(-1, -1)), minB(m, make_pair(-1, -1));
    for (ll i=0; i<n; ++i) {
        cin >> a >> b >> d;
        --d;
        if (maxA[d].second == -1 || maxA[d].second < a) {
            maxA[d].second = a;
            maxA[d].first = i;
        }
        if (minB[d].second == -1 || minB[d].second > b) {
            minB[d].second = b;
            minB[d].first = i;
        }
    }
    for (ll i=0; i<m; ++i) {
        if (minB[i].second < maxA[i].second) {
            cout << "TAK " << minB[i].first+1 << ' ' << maxA[i].first+1 << '\n';
        }
        else {
            cout << "NIE\n";
        }
    }
    return 0;
}

\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Codeforces Training S02E10
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{Codeforces Training S02E10}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{CT_S02E10/CT_S02E10_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/gym/100534}}}

\newpage
\textbf{{\large Задача A - Abnormal Coins}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_S02E10/CT_S02E10_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Будем считать сумму арифметической прогрессии с начальным членом равным $3$ и разностью $1$ и считать количество итераций в переменную $count$, пока сумма не станет больше числа $n$, тогда ответом будет значение в счётчике $count$. Сложность $O(n)$.  \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#define LL long long
using namespace std;
int main() {
    LL n;
    cin >> n;
    LL count = 0;
    LL sum = 0;
    for (LL i = 3; ; i++) {
        sum += i;
        if (sum > n) break;
        count++;
    }
    cout << count << endl;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - Fake Coins}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_S02E10/CT_S02E10_B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Нужно посчитать количество возможных кодов безопасности, которые могу быть сгенерированы. Для этого мы создадим ассоциативный массив и будем последовательно инкрементировать значения по строкам. Ответом будет размер ассоциативного массива. Сложность $O(n^2*log(n))$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <map>
#include <vector>
#define ll long long
#define ull unsigned long long
#define ERROR {out << "Error!"; return 0;}
using namespace std;
int main() {
    map<string, int> strings;
    string base, current = "";
    vector<int> spos;
    cin >> base;
    int baseSize = (int)base.size();
    for (int i = 1; i < baseSize; i++) {
        for (int j = i + 1; j <= baseSize; j++) {
            current += base[i - 1];
            current += base[j - 1];
            int cPos = i + j;
            int pPos = j, temp = 0;
            while (cPos <= baseSize) {
                current += base[cPos - 1];
                temp = pPos;
                pPos = cPos;
                cPos += temp;
            }
            strings[current]++;
            current.clear();
        }
    }

    cout << strings.size() << endl;

    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача G - Coin Game}}

\begin{center}
\includegraphics[width=0.9\textwidth]{CT_S02E10/CT_S02E10_G.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Делаем обмены сначала слева направо, потом справа налево, сравниваем в который раз получилось меньше шагов и выводим это количество шагов. Сложность $O(n)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
#define ll long long
int main()
{
    char a[25001], b[25001], c;
    int n = 0, first1 = -1, last1 = -1;
    while((c=cin.get())!='\n' && !cin.eof())
    {
        if(first1 == -1 && c == '1')
            first1 = n;
        if(c == '1')
            last1 = n;
        if(cin.eof())
            break;
        a[n] = b[n] = c;
        ++n;
    }
    a[n] = b[n] = '\0';
    ll aCount = 0, bCount = 0;
    for(ll i=0; i<n; ++i)
    {
        if(a[i] == '1')
            continue;
        for(ll j=i+1; j<n; ++j)
        {
            if(a[j] == '1')
            {
                swap(a[i], a[j]);
                aCount += j-i;
                break;
            }
        }
    }
    for(ll i=n-1; i>=0; --i)
    {
        if(b[i] == '1')
            continue;
        for(ll j=i-1; j>=0; --j)
        {
            if(b[j] == '1')
            {
                swap(b[i], b[j]);
                bCount += i-j;
                break;
            }
        }
    }
    if(aCount < bCount)
        cout << aCount;
    else
        cout << bCount;
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	OpenCup GP of Europe
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Europe}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Europe/OC_Europe_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10284}}}

\newpage
\textbf{{\large Задача E - Express As The Sum}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Europe/OC_Europe_E.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Перебираем разложения для всех $N$ пока не найдём нужное, начиная от $2$. с помощью формулы $N/i$ можно сразу найти одно из чисел, входящее в возможное разложение, а затем просто перебрать $i$ вариантов. Сложность $O(n*log(n))$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;
#define ll long long
void answer(ll n, ll l, ll r) {
    cout << n << " = " << l;
    for(ll i=l+1; i<=r; ++i) {
        cout << " + " << i;
    }
    cout.put('\n');
}
int main() {
    ll T;
    cin >> T;
    while (T--) {
        ll n;
        cin >> n;
        ll t = n;
        bool f = 0;
        while(t!=0) {
            if (t>1 && t&1) {
                f = 1;
                break;
            }
            t >>= 1;
        }
        if(!f) {
            cout << "IMPOSSIBLE\n";
            continue;
        }
        f = 0;
        for (ll i=2; !f && i<100500; ++i) {
            ll sum = 0;
            ll r = n/i;
            ll l = r-i+1;
            if(l<1) {
                l = 1;
                r = l+i-1;
            }
            for(ll j=l; j<=r; ++j) {
                sum += j;
            }
            if(sum == n) {
                answer(n, l, r);
                break;
            }
            for(ll j=r+1; j<r+i; ++j) {
                sum += j-l;
                if(sum == n) {
                    answer(n, l+1, j);
                    f = 1;
                    break;
                }
                ++l;
            }
        }
    }
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача F - Factory}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Europe/OC_Europe_F.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Находим пересекающиеся шестерёнки и строим граф их связей. Проходим от первой шестерёнки ко всем остальным с помощью обхода в ширину. Направление вращения чередуется на каждом уровне. Зная радиусы двух смежных шестерёнок и скорость одной из них, легко можно вычислить скорость другой. Сложность $O(n^2)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
using namespace std;
#define ll long long
#define ull unsigned long long
#define eps 0.00001
ll min(ll a, ll b){return (a<b?a:b);}
ll max(ll a, ll b){return (a>b?a:b);}

struct Gear {
    int x, y, r;
};

struct GearSpeed {
    ll n, d;
    bool dir;
};
int main()
{
    ll T;
    cin >> T;
    while (T--) {
        ll n;
        cin >> n;

        vector< list<int> > m(n);
        vector<bool> u(n, 0);
        vector<Gear> gears(n);
        for (ll i=0; i<n; ++i) {
            cin >> gears[i].x >> gears[i].y >> gears[i].r;
        }
        for (int i=0; i<n; ++i) {
            for (int j=i+1; j<n; ++j) {
                double x = gears[i].x-gears[j].x;
                double y = gears[i].y-gears[j].y;
                if(sqrt(x*x+y*y)<=gears[i].r+gears[j].r) {
                    m[i].insert(m[i].begin(), j);
                    m[j].insert(m[j].begin(), i);
                }
            }
        }
        vector<GearSpeed> speed(n);
        speed[0].n = 1;
        speed[0].d = 1;
        speed[0].dir = 0;
        queue<int> q;
        q.push(0);
        u[0] = 1;
        while (!q.empty()) {
            int a = q.front();
            q.pop();
            list<int>::iterator it = m[a].begin();
            for (; it!=m[a].end(); ++it) {
                int b = *it;
                if(u[b])
                    continue;
                u[b] = 1;
                speed[b].n = speed[a].n * gears[a].r;
                speed[b].d = speed[a].d * gears[b].r;
                speed[b].dir = !speed[a].dir;
                ll u = speed[b].n;
                ll v = speed[b].d;
                ll temp;
                while (v != 0) {
                    temp = u % v;
                    u = v;
                    v = temp;
                }
                speed[b].n /= u;
                speed[b].d /= u;
                q.push(b);
            }
        }
        for (ll i=0; i<n; ++i) {
            if(!u[i])
                cout << "not moving\n";
            else {
                cout << speed[i].n;
                if(speed[i].d != 1) {
                    cout << '/' << speed[i].d;
                }
                cout.put(' ');
                if(speed[i].dir) {
                    cout << "counterclockwise\n";
                }
                else {
                    cout << "clockwise\n";
                }
            }
        }
    }
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача K - Keyboard Troubles}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Europe/OC_Europe_K.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Для этой задачи пришлось заранее предпосчитать массив с правилами перехода между кнопками. Сложность $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iomanip>
#include <limits>
#include <iostream>
#include <algorithm>

#define LL  long long
#define ULL unsigned long long
#define EPS 1e-11

#define more_speed ios_base::sync_with_stdio(false);

using namespace std;

bool g(int x, int y) {

    if (x == y) return true;

    if (x == 1) {
        return true;
    }
    else if (x == 2) {
        if (y == 3 || y == 5 || y == 6 || y == 8 || y == 9 || y == 0) return true;
    }
    else if (x == 3) {
        if (y == 6 || y == 9) return true;
    }
    else if (x == 4) {
        if (y >= 4 || y == 0) return true;
    }
    else if (x == 5) {
        if (y == 6 || y == 8 || y == 9 || y == 0) return true;
    }
    else if (x == 6) {
        if (y == 9) return true;
    }
    else if (x == 7) {
        if (y >= 7 || y == 0) return true;
    }
    else if (x == 8) {
        if (y == 9 || y == 0) return true;
    }
    return false;
}

int main() {

    more_speed

    int z[] = {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1};

    int t;
    cin >> t;

    for (int i = 0; i < t; i++) {
        int n;
        cin >> n;
        if (z[n] == 1) {
            cout << n << endl;
        }
        else {
            int y = n;
            int x = n;
            while (z[x] == 0) {
                x++;
            }
            while (z[y] == 0) {
                y--;
            }
            if (n - y > x - n) {
                cout << x << endl;
            }
            else {
                cout << y << endl;
            }
        }
    }

    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача O - Allo}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Europe/OC_Europe_O.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Просто отмечаем все цифры, которые встретились в номере в булевском массиве. Потом проходим по этому массиву и проверяем остались ли неотмеченные. Если остались, то выводим их, если нет, то выводим $allo$. Сложность $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
using namespace std;
#define ll long long
#define ull unsigned long long
ll min(ll a, ll b){return (a<b?a:b);}
ll max(ll a, ll b){return (a>b?a:b);}
int main()
{
    ll T;
    cin >> T;
    cin.get();
    while (T--) {
        vector<bool> nums(10, 0);
        char c;
        while((c=cin.get())!='\n' && !cin.eof())
        {
            if(cin.eof())
                break;
            nums[c-'0'] = 1;
        }
        bool f = 0;
        for(ll i=0; i<10; ++i)
        {
            if(!nums[i])
            {
                f = 1;
                cout << i;
            }
        }
        if(!f)
            cout << "allo";
        cout << '\n';

    }
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача N - C\,-\,-}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Europe/OC_Europe_N.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Задача на реализацию. При объявлении переменной, она добавляется в стек в виде структуры $pair$, в которой первый элемент - значение переменной, а второй - номер области видимости. При выходе из текущей области видимости, все переменный, созданные в ней, удаляются из стека. Сложность $O(n)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
using namespace std;
#define ll long long
int main()
{
    ll n;
    vector < stack< pair<ll, int> > > vars(26);
    int scope = 0;
    cin >> n;
    char str[20];
    for (int i=0; i<n; ++i) {
        cin >> str;
        if(str[0] == '{') {
            ++scope;
        }
        else if(str[0] == '}') {
            for (int i=0; i<26; ++i) {
                if(!vars[i].empty() && vars[i].top().second == scope) {
                    vars[i].pop();
                }
            }
            --scope;
        }
        else if(str[1] == '=') {
            int c1 = str[0]-'a';
            ll a;
            if(isalpha(str[2])) {
                int c2 = str[2]-'a';
                a = vars[c2].top().first;
                int c1Scope = vars[c1].top().second;
                vars[c1].pop();
                vars[c1].push(make_pair(a, c1Scope));
            }
            else {
                a = 0;
                for (int i=2; str[i]!='\0'; ++i)
                    a = a*10+str[i]-'0';
            }
            int c1Scope = vars[c1].top().second;
            vars[c1].pop();
            vars[c1].push(make_pair(a, c1Scope));
        }
        else if(!strcmp(str, "int")) {
            cin >> str;
            int c;
            c = str[0]-'a';
            vars[c].push(make_pair(-1, scope));
        }
        else if(!strcmp(str, "print")) {
            cin >> str;
            int c = str[0]-'a';
            cout << vars[c].top().first << '\n';
        }
    }
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	OpenCup GP of Peterhof
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Peterhof}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Peterhof/OC_Peterhof_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10285}}}

\newpage
\textbf{{\large Задача H - Некратчайший путь}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Peterhof/OC_Peterhof_H1.png}\\ [1cm]
\includegraphics[width=0.9\textwidth]{OC_Peterhof/OC_Peterhof_H2.png}\\ [1cm]
\end{center}
\newpage

\textbf{{\large Алгоритм}}

С помощью рекурсии находим все возможные пути и составляем из них вектор. Находим среди них кратчайший и после этого находим путь, который не является кратчайшим, если же не находим, то выводим $-1$. Сложность $O(n^2)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
#include <map>
using namespace std;
#define ll long long
#define ull unsigned long long
#define eps 0.00001
ll min(ll a, ll b){return (a<b?a:b);}
ll max(ll a, ll b){return (a>b?a:b);}

vector < vector<char> > paths;
vector<char> path;
size_t __min;

void foo(char map[4][4], int x, int y) {
    if (x == 3 && y == 3) {
        if (path.size() < __min) {
            __min = path.size();
        }
        paths.push_back(path);
    }
    if (x<3 && map[y][x+1] == '.') {
        path.push_back('R');
        map[y][x] = 'X';
        foo(map, x+1, y);
        map[y][x] = '.';
        path.pop_back();
    }
    if (x>0 && map[y][x-1] == '.') {
        path.push_back('L');
        map[y][x] = 'X';
        foo(map, x-1, y);
        map[y][x] = '.';
        path.pop_back();
    }
    map[y][x] = '.';
    if (y<3 && map[y+1][x] == '.') {
        path.push_back('D');
        map[y][x] = 'X';
        foo(map, x, y+1);
        map[y][x] = '.';
        path.pop_back();
    }
    map[y][x] = '.';
    if (y>0 && map[y-1][x] == '.') {
        path.push_back('U');
        map[y][x] = 'X';
        foo(map, x, y-1);
        map[y][x] = '.';
        path.pop_back();
    }
}

int main()
{
    char map[4][4];
    bool e = 1;
    while (e) {
        for (int i=0; i<4; ++i) {
            for (int j=0; j<4; ++j) {
                map[i][j] = cin.get();
            }
            cin.get();
        }
        __min = 100500;
        foo(map, 0, 0);
        bool f = 0;
        for (int i=0; i<paths.size(); ++i) {
            if (paths[i].size() != __min) {
                for (int j=0; j<paths[i].size(); ++j) {
                    cout.put(paths[i][j]);
                }
                f = 1;
                break;
            }
        }
        if (!f) {
            cout << -1;
        }
        cout.put('\n');
        for (int i=0; i<5; ++i) {
            cin.get();
            if (cin.eof()) {
                e = 0;
                break;
            }
        }
        paths.clear();
        path.clear();
    }
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	OpenCup GP of Japan
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Japan}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Japan/OC_Japan_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10286}}}

\newpage
\textbf{{\large Задача K - Beads}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Japan/OC_Japan_K.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Для того чтобы решить задачу, нужно найти минимальный циклический сдвиг, для этого мы применим алгоритм Дюваля. Сложность $O(n)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>

using namespace std;

long min_cyclic_shift (string s) {
    s += s;
    long n = (long) s.length();
    long i = 0, ans = 0;
    while (i < n/2) {
        ans = i;
        long j = i + 1, k = i;
        while (j < n && s[k] <= s[j]) {
            if (s[k] < s[j])
                k = i;
            else
                ++k;
            ++j;
        }
        while (i <= k)  i += j - k;
    }
    return ans;
}

int main(int argc, const char * argv[]) {
    long n;
    string s;
    cin >> n >> s;
    long answer = min_cyclic_shift(s);
    cout << answer + 1 << endl;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача L - The Maximum Sum}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Japan/OC_Japan_L.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Задача решается простым перебором всех слагаемых. Сложность $O(n^2)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iomanip>
#include <iostream>
#include <algorithm>
int main() {
    int n, M;
	cin >> n >> M;
	vector <int> num;
	int temp;
	for (int i = 0; i < n; i++) {
		cin >> temp;
		num.push_back(temp);
	}
	int max_sum = 0;
	for(int i = 0; i < n; i++)
		for(int j = i + 1; j < n; j++) {
			temp = num[i] + num[j];
			if(temp <= M && temp > max_sum)
				max_sum = temp;
		}
	cout << max_sum << endl;
    cin >> n;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача M - Spellcheck}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Japan/OC_Japan_M.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Просто сравним все входные слова через $strcmp$, и если будет совпадение, то инкрементируем счётчик ошибок для строки. Сложность $O(n)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    long T;
    cin >> T;
    char aStr[100], bStr[100];
    cin.get();
    while (T--) {
        char c;
        long a = 0, aN = 0, bN = 0, res = 0;
        while (c = cin.get()) {
            if (c == ' ' || c == '\n') {
                if (a&1) {
                    if (!strcmp("u", bStr) || !strcmp("ur", bStr) || strstr(bStr, "lol") != NULL) {
                        ++res;
                    }
                    else if((!strcmp("would", aStr) || !strcmp("should", aStr)) && !strcmp("of", bStr)) {
                        ++res;
                    }
                    aN = 0;
                }
                else {
                    if (!strcmp("u", aStr) || !strcmp("ur", aStr) || strstr(aStr, "lol") != NULL) {
                        ++res;
                    }
                    else if(a && (!strcmp("would", bStr) || !strcmp("should", bStr)) && !strcmp("of", aStr)) {
                        ++res;
                    }
                    bN = 0;
                }
                if (c == '\n') {
                    break;
                }
                ++a;
                continue;
            }
            if (a&1) {
                bStr[bN++] = c;
                bStr[bN] = '\0';
            }
            else {
                aStr[aN++] = c;
                aStr[aN] = '\0';
            }
        }
        cout << res << '\n';
    }
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача N - Bluetooth}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Japan/OC_Japan_N.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Составляем граф связей между смартфонами. Затем с помощью поиска в ширину пытаемся добраться до смартфона друга. Если получилось, то выводим $y$, если нет, то $n$. Сложность $O(n^2+n)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iomanip>
#include <limits>
#include <iostream>
#include <algorithm>
double dist(const pair<int, int> &a, const pair<int, int> &b) {
    double x, y;
    x = (a.first - b.first);
    y = (a.second - b.second);
    x *= x;
    y *= y;
    return sqrt(x + y);
}
int main() {
    int n, d;
    cin >> n >> d;
    vector<pair<int, int> > points(n);
    for (int i = 0; i < n; i++) {
        cin >> points[i].first >> points[i].second;
    }
    vector<vector<int> > g(n, vector<int>());
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i != j) {
                double dis = dist(points[i], points[j]);
                if (dis <= d) {
                    g[i].push_back(j);
                }
            }
        }
    }
    int s = 0;
    queue<int> q;
    q.push(s);
    vector<bool> used (n);
    used[s] = true;
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (size_t i = 0; i < g[v].size(); ++i) {
            int to = g[v][i];
            if (!used[to]) {
                if (to == n - 1) {
                    cout << "y" << endl;
                    return 0;
                }
                used[to] = true;
                q.push (to);
            }
        }
    }
    cout << "n" << endl;
    return 0;
}
\end{lstlisting}





%----------------------------------------------------------------------------------------
%
%	OpenCup GP Northern
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup Northern GrandPrix}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Northern/OC_Northern_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10287}}}

\newpage
\textbf{{\large Задача K - Kill The PSU}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Northern/OC_Northern_K1.png}\\ [1cm]
\includegraphics[width=0.9\textwidth]{OC_Northern/OC_Northern_K2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Задача на реализацию. Нужно построить что-то на подобии экспертной системы по заданным правилам. Сложность $O(n)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iomanip>
#include <iostream>
#include <algorithm>
#include <vector>
#include <fstream>
#define LL  long long
using namespace std;
ifstream in("killthepsu.in");
ofstream out("killthepsu.out");

class item {
public:
    string name;
    virtual void message() = 0;
};
class cat1 : public item {
public:
    void message() {
        out << "wake " << name << endl;
    }
    cat1(string n) {
        name = n;
    }
};
class cat2 : public item {
public:
    bool load;
    void message() {
        if (load) {
            out << "unload ";
            load = false;
        }
        else {
            out << "load ";
            load = true;
        }
        out << name << endl;
    }
    cat2(string n) {
        name = n;
        load = false;
    }
};
int reserve = 20;
bool nextIter = false;
class cat3 : public item {
public:
    int power;
    void message() {
        if (reserve) {
            reserve -= 10;
            out << "power fail on " << name << endl;
            return;
        }
        power -= 10;
        if (power > 10) {
            out << "power fail on " << name << endl;
        }
        else if (power <= 10) {
            out << "buy the new PSU" << endl;
            nextIter = true;
        }
    }
    cat3(string n) {
        power = 100;
        name = n;
    }
};

int main() {
    int t;
    in >> t;
    for (int k = 0; k < t; k++) {
        reserve = 20;
        map<string, item *> system;
        int a, b, c, d;
        in >> a >> b >> c >> d;
        string name;
        in.get();

        for (int i = 0; i < a; i++) {
            getline(in, name);
            item *newItem = new cat1(name);
            system[name] = newItem;
        }
        for (int i = 0; i < b; i++) {
            getline(in, name);
            item *newItem = new cat2(name);
            system[name] = newItem;
        }
        for (int i = 0; i < c; i++) {
            getline(in, name);
            item *newItem = new cat3(name);
            system[name] = newItem;
        }
        for (int i = 0; i < d; i++) {
            getline(in, name);
            if (!nextIter) {
                map<string, item *>::iterator current = system.find(name);
                if (current != system.end())
                    current->second->message();
            }
        }
        nextIter = false;
    }
    in.close();
    out.close();
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача M - Мозаика}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Northern/OC_Northern_M.png}\\ [1cm]
\end{center}
\newpage

\textbf{{\large Алгоритм}}

Если $N$ или $M$ меньше трёх, то ответ будет $0$, если нет, то вычисляем максимальное количество плиток по выведенной формуле и заполняем мозаику. Сложность $O(N*M)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iomanip>
#include <limits>
#include <iostream>
#include <algorithm>

using namespace std;

int main() {
    ifstream in("mosaic.in");
    ofstream out("mosaic.out");

	int N, M;
	in >> M >> N;
	int answ;

	if(N < 3 || M < 3) {
		out << "0" << endl;
		return 0;
	}
	if((N - 2)*(M - 2) % 2 == 0)
		answ = (N - 2)*(M - 2) / 2;
	else
		answ = (N - 2)*(M - 2) / 2 + 1;

	out << answ << endl;

	int k = 2;
	for(int i = 2; i < M; i++) {
		for(int j = k; j < N; j+=2) {
			out << (i - 1)*N + j << " ";
		}
		if(k == 2)
			k = 3;
		else k = 2;
	}

    in.close();
    out.close();

    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	OpenCup GP of Karelia
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Karelia}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Karelia/OC_Karelia_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10288}}}

\newpage
\textbf{{\large Задача I - Jam}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Karelia/OC_Karelia_I.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

На каждой остановке смотрим, если вышло человек больше чем вошло, то прибавляем к ответу разницу между вошедшими и вышедшими. Выводим ответ. Сложность $O(n)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>

int main() {
    ifstream in("jam.in");

    int T;
    in >> T;

    while (T--) {
        int m, zashli, vishli;
        long ans = 0;
        long buf = 0;
        in >> m;
        for (int i = 0; i < m; i++) {
            in >> zashli >> vishli;
            zashli += buf;
            int diff = zashli - vishli;
            if (diff < 0) {
                ans += diff * (-1);
                buf = 0;
            }
            else {
                buf = diff;
            }
        }
        cout << ans << endl;
    }
    in.close();
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача J - King of Guess}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Karelia/OC_Karelia_J.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Задача решается прямой симуляцией процесса игры по довольно простым правилам, заданным в условии задачи. Сложность $O(log(n))$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>

int main() {
    ifstream in("kingofguess.in");
	int X;
	int N;
	int Y;
	int mid;
	int step = 0;

	in >> N >> X >> Y;

	while(true) {
		step++;
		mid = (X + Y)/2;
		if(mid == N) {
			cout << step << endl;
			//cin >> N;
			return 0;
		}
		if(mid > N)
			Y = mid;
		if(mid < N)
			X = mid;
	}
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача K - Lesson}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Karelia/OC_Karelia_K.png}\\ [1cm]
\end{center}
\newpage

\textbf{{\large Алгоритм}}

Нужно воспроизвести игру "Морской бой" по ходам обоих игроков. Сложность $O(n^2)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;
#define ll long long
#define ull unsigned long long
#define eps 0.00001
ll min(ll a, ll b){return (a<b?a:b);}
ll max(ll a, ll b){return (a>b?a:b);}

int main()
{
    ifstream in("lesson.in");

    long T;
    in >> T;
    in.get();
    const string names[] = {"Sail", "Frigate", "Cruiser", "Dreadnought"};
    while (T--) {
        ll n;
        in >> n;
        in.get();
        char mapA[10][10], mapB[10][10];
        vector< pair<int, int> > A(4, make_pair(0, 0)), B(4, make_pair(0, 0));
        for(ll i=0; i<n; ++i) {
            for (ll j=0; j<n; ++j) {
                mapA[i][j] = in.get();
                if (mapA[i][j] != '.')
                    ++A[mapA[i][j]-'0'-1].first;
            }
            in.get();
        }
        for(ll i=0; i<n; ++i) {
            for (ll j=0; j<n; ++j) {
                mapB[i][j] = in.get();
                if (mapB[i][j] != '.')
                    ++B[mapB[i][j]-'0'-1].first;
            }
            in.get();
        }
        vector< pair<ll, ll> > movesA(n*n), movesB(n*n);
        for (ll i=0; i<n*n; ++i) {
            ll x, y;
            in >> y >> x;
            movesA[i] = make_pair(y - 1, x - 1);
        }
        for (ll i=0; i<n*n; ++i) {
            ll x, y;
            in >> y >> x;
            movesB[i] = make_pair(y - 1, x - 1);
        }
        ll shipsA = 4, shipsB = 4;
        bool win = 0;
        for (ll moveA = 0, moveB = 0; moveA < n*n && moveB < n*n && !win;) {
            ll y, x;
            bool f = 1;
            while (f) {
                f = 0;
                x = movesA[moveA].second;
                y = movesA[moveA].first;
                ++moveA;
                if (mapB[y][x] != '.') {
                    ++B[mapB[y][x]-'0'-1].second;
                    if (B[mapB[y][x]-'0'-1].second == B[mapB[y][x]-'0'-1].first) {
                        cout << "Alice sank Bob's " << names[B[mapB[y][x]-'0'-1].first-1] << '\n';
                        f = 1;
                        --shipsB;
                        if (!shipsB) {
                            cout << "Alice\n";
                            win = 1;
                            break;
                        }
                    }
                }
            }
            if (win) {
                break;
            }
            f = 1;
            while (f) {
                f = 0;
                x = movesB[moveB].second;
                y = movesB[moveB].first;
                ++moveB;
                if (mapA[y][x] != '.') {
                    ++A[mapA[y][x]-'0'-1].second;
                    if (A[mapA[y][x]-'0'-1].second == A[mapA[y][x]-'0'-1].first) {
                        cout << "Bob sank Alice's " << names[A[mapA[y][x]-'0'-1].first-1] << '\n';
                        f = 1;
                        --shipsA;
                        if (!shipsA) {
                            cout << "Bob\n";
                            win = 1;
                            break;
                        }
                    }
                }
            }
            if (win) {
                break;
            }
        }
    }

    in.close();
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача L - Maze}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Karelia/OC_Karelia_L1.png}\\ [1cm]
\includegraphics[width=0.9\textwidth]{OC_Karelia/OC_Karelia_L2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Создаём матрицу, изначально заполненную решётками. Воспроизводим путь робота согласно входным символам и отмечаем путь точками, в процессе запоминая максимальную и минимальную координаты. Используя найденные граничные координаты, вычисляем размер поля и выводим само поле. Сложность $O(n)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;
int main() {
    ifstream in("maze.in");
    long T;
    in >> T;
    in.get();
    while (T--) {
        char map[210][210];
        for (ll i=0; i<210; ++i) {
            for (ll j=0; j<210; ++j) {
                map[i][j] = 'X';
            }
        }
        ll maxX = 0, maxY = 0, minX = 0, minY = 0, x = 0, y = 0;
        int dir = 0;
        char c;
        while((c = in.get()) != '\n') {
            if (c == 'B') {
                if (dir == 0) dir = 2;
                else if (dir == 1) dir = 3;
                else if (dir == 2) dir = 0;
                else if (dir == 3) dir = 1;
            }
            else if (c == 'R') {
                if (dir == 0) dir = 3;
                else if (dir == 1) dir = 0;
                else if (dir == 2) dir = 1;
                else if (dir == 3) dir = 2;
            }
            else if (c == 'L') {
                if (dir == 0) dir = 1;
                else if (dir == 1) dir = 2;
                else if (dir == 2) dir = 3;
                else if (dir == 3) dir = 0;
            }
            map[x+105][y+105] = '.';
            if (dir == 0) ++x;
            else if (dir == 1) --y;
            else if (dir == 2) --x;
            else ++y;
            if (x > maxX) maxX = x;
            else if(x < minX) minX = x;
            if (y > maxY) maxY = y;
            else if(y < minY) minY = y;
        }
        cout << maxY - minY + 3 << ' ' << maxX - minX + 2 << '\n';
        for (ll i=minY-1; i<maxY+2; ++i) {
            for (ll j=minX; j<maxX+2; ++j) {
                cout.put(map[j+105][i+105]);
            }
            cout.put('\n');
        }
    }
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	OpenCup GP of Udmurtia
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Udmurtia}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Udmurtia/OC_Udmurtia_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10289}}}

\newpage
\textbf{{\large Задача A - Коллекционеры}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Udmurtia/OC_Udmurtia_A1.png}\\ [1cm]
\includegraphics[width=0.9\textwidth]{OC_Udmurtia/OC_Udmurtia_A2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Логическая задача на реализацию. Расписываем все условия из задачи для каждого человека и затем последовательно применяем их ко входным данным. Сложность $O(1)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>

typedef enum {
    BLACK,
    WHITE,
    GREEN,
    YELLOW,
    BLUE,
    RED,
    ORANGE,
    PURPLE
} color;

typedef enum {
    DOT,
    ARABIC,
    ROMAN,
} numberType;

typedef struct {
    color col;
    numberType num;
    int value;
} cubeFace;

color parseColor(char col) {
    if (col == 'B') return BLACK;
    else if (col == 'W') return WHITE;
    else if (col == 'G') return GREEN;
    else if (col == 'Y') return YELLOW;
    else if (col == 'S') return BLUE;
    else if (col == 'R') return RED;
    else if (col == 'O') return ORANGE;
    else return PURPLE;
}

int parseDots() {
    int value;
    string dots;
    in >> dots;
    value = (int)dots.size();
    return value;
}

int parseArabic() {
    int value;
    in >> value;
    return value;
}

int parseRoman() {
    string roman;
    in >> roman;
    if (roman == "I") return 1;
    else if (roman == "II") return 2;
    else if (roman == "III") return 3;
    else if (roman == "IV") return 4;
    else if (roman == "V") return 5;
    else return 6;
}

int parseValue(numberType num) {
    if (num == DOT) return parseDots();
    else if (num == ARABIC) return parseArabic();
    else return parseRoman();
}

numberType recognizeNumberType(char num) {
    if (num == '.') return DOT;
    else if (isdigit(num)) return ARABIC;
    else return ROMAN;
}

bool john(cubeFace f1, cubeFace f2, cubeFace f3) {
    if (f1.num == DOT && f1.num == f2.num && f2.num == f3.num)
        return true;
    return false;
}

bool david(cubeFace f1, cubeFace f2, cubeFace f3) {
    if (f1.num != ROMAN && f2.num != ROMAN && f3.num != ROMAN)
        return true;
    return false;
}

bool peter(cubeFace f1, cubeFace f2, cubeFace f3) {
    if (f1.col == WHITE && f1.col == f2.col && f2.col == f3.col)
        return true;
    return false;
}

bool robert(cubeFace f1, cubeFace f2, cubeFace f3) {
    if ((f1.col == BLACK || f1.col == WHITE) &&
        (f2.col == BLACK || f2.col == WHITE) &&
        (f3.col == BLACK || f3.col == WHITE))
        return true;
    return false;
}

bool mark(cubeFace f1, cubeFace f2, cubeFace f3) {
    if (f1.value % 2 == 0 && f1.col != BLACK)
        return false;
    if (f1.value % 2 == 1 && f1.col != WHITE)
        return false;
    if (f2.value % 2 == 0 && f2.col != BLACK)
        return false;
    if (f2.value % 2 == 1 && f2.col != WHITE)
        return false;
    if (f3.value % 2 == 0 && f3.col != BLACK)
        return false;
    if (f3.value % 2 == 1 && f3.col != WHITE)
        return false;
    return true;
}

bool paul(cubeFace f1, cubeFace f2, cubeFace f3) {
    if (f1.value == 2 || f1.value == 3 || f1.value == 5) {
        if (f1.num != ARABIC)
            return false;
    }
    if (f2.value == 2 || f2.value == 3 || f2.value == 5) {
        if (f2.num != ARABIC)
            return false;
    }
    if (f3.value == 2 || f3.value == 3 || f3.value == 5) {
        if (f3.num != ARABIC)
            return false;
    }
    if (f1.num == ARABIC) {
        if (f1.value == 1 || f1.value == 4 || f1.value == 6) {
            return false;
        }
    }
    if (f2.num == ARABIC) {
        if (f2.value == 1 || f2.value == 4 || f2.value == 6) {
            return false;
        }
    }
    if (f3.num == ARABIC) {
        if (f3.value == 1 || f3.value == 4 || f3.value == 6) {
            return false;
        }
    }
    return true;
}

bool patrick(cubeFace f1, cubeFace f2, cubeFace f3) {
    if (f1.col == f2.col && f2.col == f3.col) {
        if (f1.col != BLACK && f1.col != WHITE)
            return true;
    }
    return false;
}

bool jack(cubeFace f1, cubeFace f2, cubeFace f3) {
    if (f1.num == ROMAN && f1.col != YELLOW)
        return false;
    if (f2.num == ROMAN && f2.col != YELLOW)
        return false;
    if (f3.num == ROMAN && f3.col != YELLOW)
        return false;
    return true;
}

bool maxx(cubeFace f1, cubeFace f2, cubeFace f3) {
    if (f1.col != f2.col && f1.col != f3.col && f2.col != f3.col)
        return true;
    return false;
}

bool alex(cubeFace f1, cubeFace f2, cubeFace f3) {
    if (f1.num == f2.num && f1.col != f2.col)
        return false;
    if (f1.num != f2.num && f1.col == f2.col)
        return false;

    if (f1.num == f3.num && f1.col != f3.col)
        return false;
    if (f1.num != f3.num && f1.col == f3.col)
        return false;

    if (f2.num == f3.num && f2.col != f3.col)
        return false;
    if (f2.num != f3.num && f2.col == f3.col)
        return false;

    return true;
}

int main() {

    char col, num;

    // FACE 1
    cubeFace face1;
    col = in.get();
    in.get();

    num = in.get();
    in.unget();

    face1.col = parseColor(col);
    face1.num = recognizeNumberType(num);
    face1.value = parseValue(face1.num);
    in.get();

    // FACE 2
    cubeFace face2;
    col = in.get();
    in.get();

    num = in.get();
    in.unget();

    face2.col = parseColor(col);
    face2.num = recognizeNumberType(num);
    face2.value = parseValue(face2.num);
    in.get();

    // FACE 3
    cubeFace face3;
    col = in.get();
    in.get();

    num = in.get();
    in.unget();

    face3.col = parseColor(col);
    face3.num = recognizeNumberType(num);
    face3.value = parseValue(face3.num);
    in.get();

    if (john(face1, face2, face3))
        out << "John ";
    if (david(face1, face2, face3))
        out << "David ";
    if (peter(face1, face2, face3))
        out << "Peter ";
    if (robert(face1, face2, face3))
        out << "Robert ";
    if (mark(face1, face2, face3))
        out << "Mark ";
    if (paul(face1, face2, face3))
        out << "Paul ";
    if (patrick(face1, face2, face3))
        out << "Patrick ";
    if (jack(face1, face2, face3))
        out << "Jack ";
    if (maxx(face1, face2, face3))
        out << "Max ";
    if (alex(face1, face2, face3))
        out << "Alex ";

    in.close();
    out.close();

    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача K - Data Mining}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Udmurtia/OC_Udmurtia_K.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Подсчитываем время выполнения программы без её переписывания и с переписыванием и сравниваем. Сложность $O(1)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>

int main() {
    ifstream in("input.txt");
    ofstream out("output.txt");

    long T;
    in >> T;
    while (T--) {
        long dev, runs, execParallel, execCurrent;
        in >> dev >> runs >> execCurrent >> execParallel;
        long keepTime, rewriteTime;
        keepTime = runs * execCurrent;
        rewriteTime = dev + runs * execParallel;
        if (keepTime < rewriteTime) {
            out << "Keep" << endl;
        }
        else if (keepTime > rewriteTime) {
            out << "Rewrite" << endl;
        }
        else {
            out << "Flip a Coin" << endl;
        }
    }

    in.close();
    out.close();

    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача L - Performance}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Udmurtia/OC_Udmurtia_L.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Вычисляем квадратное уравнение, выведенное из заданной формулы и находим передачу с максимальной производительностью. Сложность $O(n)$. \\

\textbf{{\large Исходный код}}
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>

typedef struct {
    long gear;
    long a, b, c;
} eq;

int main() {
    ifstream in("input.txt");
    ofstream out("output.txt");

    int T;
    in >> T;
    while (T--) {
        long maxGear = 0;
        double maxValue = -1000000;
        int n;
        in >> n;
        for (int i = 1; i <= n; i++) {
            long a, b, c;
            in >> a >> b >> c;
            double max = (-1) * (((b * b) - (4 * (-a) * c)) / (4 * (-a)));
            if (max > maxValue) {
                maxValue = max;
                maxGear = i;
            }
        }
        out << maxGear << endl;
    }

    in.close();
    out.close();

    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача M - Tic-tac-toe}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Udmurtia/OC_Udmurtia_M.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Перебираем все возможные варианты ходов и подсчитываем кто из игроков выигравает в большинстве ходов. Сложность $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;
#define ll long long
#define ull unsigned long long
#define eps 0.00001
ll min(ll a, ll b){return (a<b?a:b);}
ll max(ll a, ll b){return (a>b?a:b);}

struct Point{
    int x, y;
};

int check(char map[3][3]) {
    int winner = 2;
    for (int i=0; i<3; ++i) {
        bool oFH = 1, xFH = 1, oFV = 1, xFV = 1;
        for (int j=0; j<3; ++j) {
            if (map[i][j] != 'o') {
                oFH = 0;
            }
            if (map[i][j] != 'x') {
                xFH = 0;
            }
            if (map[j][i] != 'o') {
                oFV = 0;
            }
            if (map[j][i] != 'x') {
                xFV = 0;
            }
        }
        if (oFH || oFV) {
            winner = 1;
        }
        else if (xFH || xFV) {
            winner = 0;
        }
    }
    bool oFD1 = 1, xFD1 = 1, oFD2 = 1, xFD2 = 1;
    for (int i=0; i<3; ++i) {
        if (map[i][i] != 'o') {
            oFD1 = 0;
        }
        if (map[i][i] != 'x') {
            xFD1 = 0;
        }
        if (map[i][2-i] != 'o') {
            oFD2 = 0;
        }
        if (map[i][2-i] != 'x') {
            xFD2 = 0;
        }
    }

    if (oFD1 || oFD2) {
        winner = 1;
    }
    else if (xFD1 || xFD2) {
        winner = 0;
    }
    return winner;
}
int main()
{
    ifstream in("input.txt");
    ofstream out("output.txt");

    Point freeCell[2];
    int n = 0;
    int xN = 0, oN = 0;
    char map[3][3];
    for (int i=0; i<3; ++i) {
        for (int j=0; j<3; ++j) {
            map[i][j] = in.get();
            if (map[i][j] == '.') {
                freeCell[n].x = j;
                freeCell[n].y = i;
                ++n;
            }
            if (map[i][j] == 'x') {
                ++xN;
            }
            else if (map[i][j] == 'o') {
                ++oN;
            }
        }
        in.get();
    }
    char firstPlayer, secondPlayer;
    if (oN < xN) {
        firstPlayer = 'o';
        secondPlayer = 'x';
    }
    else {
        firstPlayer = 'x';
        secondPlayer = 'o';
    }
    map[freeCell[0].y][freeCell[0].x] = firstPlayer;
    int winner = check(map);
    float pX = 0, pO = 0;
    if (firstPlayer == 'o' && winner == 1 || firstPlayer == 'x' && winner == 0) {
        pO += 1;
    }
    else {
        map[freeCell[1].y][freeCell[1].x] = secondPlayer;
        winner = check(map);
        if (firstPlayer == 'o' && winner == 0 || firstPlayer == 'x' && winner == 1) {
            pX += 1;
        }
    }

    map[freeCell[0].y][freeCell[0].x] = '.';
    map[freeCell[1].y][freeCell[1].x] = firstPlayer;
    winner = check(map);
    if (firstPlayer == 'o' && winner == 1 || firstPlayer == 'x' && winner == 0) {
        pO += 1;
    }
    else {
        map[freeCell[0].y][freeCell[0].x] = secondPlayer;
        winner = check(map);
        if (firstPlayer == 'o' && winner == 0 || firstPlayer == 'x' && winner == 1) {
            pX += 1;
        }
    }

    if (pO > pX) {
        if (firstPlayer == 'o')
            out << "o";
        else
            out << "x";
    }
    else if (pO < pX) {
        if (secondPlayer == 'x')
            out << "x";
        else
            out << "o";
    }
    else {
        out << "tie";
    }
    in.close();
    out.close();
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	OpenCup GP of China
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of China}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_China/OC_China_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10300}}}

\newpage
\textbf{{\large Задача N - Ordered Sequences}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_China/OC_China_N.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Представим последовательность символов $'A'$ и $'B'$ как двоичное число в котором единица - это $'B'$, а ноль - это $'A'$. Тогда ответом будет просто значение этого числа в десятичном представлении. Сложность $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
using namespace std;
#define ll long long
#define ull unsigned long long
#define eps 0.00001
ll min(ll a, ll b){return (a<b?a:b);}
ll max(ll a, ll b){return (a>b?a:b);}

int main()
{
    int T;
    cin >> T;
    cin.get();
    while (T--) {
        ull a = 0;
        char c;
        while ((c=cin.get())!='\n') {
            a <<= 1;
            if (c == 'B') {
                a |= 1;
            }
        }
        cout << a << '\n';
    }
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	OpenCup GP of Tatarstan
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Tatarstan}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Tatarstan/OC_Tatarstan_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10301}}}

\newpage
\textbf{{\large Задача M - The Dress}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Tatarstan/OC_Tatarstan_M.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Делаем поиск в строке по ключевым словам и подсчитываем количество существ для  каждой группы. Затем выводим в процентах. Сложность $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>

int main(){
    int n;
    cin >> n;
    int humans = 0;
    int aliens = 0;
    int fuckers = 0;
    int total = n;
    string answer;
    cin.get();

    while (n--) {
        getline(cin, answer);
        if (answer.find("blue") != -1 && answer.find("black") != -1) {
            humans++;
        }
        else if (answer.find("gold") != -1 && answer.find("white") != -1) {
            aliens++;
        }
        else {
            fuckers++;
        }
    }

    cout << setprecision(10) << (double)humans / total * 100 << endl;
    cout << setprecision(10) << (double)aliens / total * 100 << endl;
    cout << setprecision(10) << (double)fuckers / total * 100 << endl;
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	OpenCup GP of America
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of America}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_America/OC_America_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=10302}}}

\newpage
\textbf{{\large Задача J - Zig Zag Nametag}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_America/OC_America_J.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Составляем строку из чередующихся букв $'a'$ и $'z'$. Меняем некоторые буквы на $'b'$ или $'y'$ если получившаяся строка не удовлетворяет условиям. Сложность $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>

int main(){
    long k;
    cin >> k;
    long length = (k - 1) / 25 + 2;

    string s = "";
    for (long i = 0; i < length; i++) {
        if (i  % 2)
            s += "z";
        else
            s += "a";
    }

    if (length > 2) {
        s[1] = (char)('n' + (k - 25 * (length - 2)) / 2);
        long last = s.size() - 1;
        if (s[last] == 'z' && k % 2 == 0) {
            s[last] = 'y';
        }
        else if (s[last] == 'a' && k % 2 == 1) {
            s[last] = 'b';
        }
    }
    else {
        s[0] = 'a';
        s[1] = 'a' + k;
    }
    cout << s << endl;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача K - Knight Jumps}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_America/OC_America_K.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Построим граф всех возможных ходов коня. С помощью поиска в ширину найдём минимальное количество шагов до цели. Сложность $O(n+m)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>
#include <vector>

int main(){
    int n, m;
    cin >> n >> m;

    int x_num = 0;
    int k_num = 0;

    char symb;

    vector<bool> used(n * m, false);
    vector<vector<int> > g(n * m, vector<int>());

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> symb;
            //used[i][j] = false;
            if (symb == '#') {
                used[i * m + j] = true;
            }
            else if (symb == 'K') {
                k_num = i * m + j;
                used[i * m + j] = true;
            }
            else if (symb == 'X') {
                x_num = i * m + j;
            }
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            int to = i * m + j;

            if (i - 2 >= 0 && j - 1 >= 0)
                g[to].push_back((i - 2) * m + (j - 1));
            if (i - 2 >= 0 && j + 1 < m)
                g[to].push_back((i - 2) * m + (j + 1));

            if (i - 1 >= 0 && j - 2 >= 0)
                g[to].push_back((i - 1) * m + (j - 2));
            if (i + 1 < n && j - 2 >= 0)
                g[to].push_back((i + 1) * m + (j - 2));

            if (i + 2 < n && j - 1 >= 0)
                g[to].push_back((i + 2) * m + (j - 1));
            if (i + 2 < n && j + 1 < m)
                g[to].push_back((i + 2) * m + (j + 1));

            if (i - 1 >= 0 && j + 2 < m)
                g[to].push_back((i - 1) * m + (j + 2));
            if (i + 1 < n && j + 2 < m)
                g[to].push_back((i + 1) * m + (j + 2));
        }
    }

    queue<int> ways;
    used[k_num] = true;
    ways.push(k_num);

    vector<int> d(n * m), p(n * m);
    p[k_num] = -1;

    while (!ways.empty()) {
        int v = ways.front();
        ways.pop();
        for (size_t i = 0; i < g[v].size(); ++i) {
            int to = g[v][i];
            if (!used[to]) {
                used[to] = true;
                ways.push(to);
                d[to] = d[v] + 1;
                p[to] = v;
            }
        }
    }

    if (!used[x_num])
        cout << "-1" << endl;
    else {
        vector<int> path;
        for (int v = x_num; v!= -1; v = p[v])
            path.push_back (v);
        cout << path.size() - 1 << endl;
    }
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача M - Multiple Tom N}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_America/OC_America_M1.png}\\ [1cm]
\includegraphics[width=0.9\textwidth]{OC_America/OC_America_M2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Считываем буквы обоих команд в два вектора в виде номера буквы. Далее циклом проходим одновременно по двум векторам и сравниваем буквы. Если буквы равны, то выводим $1$, а если буквы различны, то для каждого вектора начинаем считать сумму букв тем самым добавляя их в два множества (для каждого вектора своё) и подсчитываем количество букв в этих множествах. Делаем это до тех пор пока сумма обоих множеств не станет равна и соответственно оба множества будут равны. Когда они станут равны, выводим количество элементов во множествах и обнуляем их. Сложность $O(n)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>
#include <vector>

#define LL  long long
#define ULL unsigned long long

int main() {
	ULL n;
	cin >> n;

	vector <ULL> v1(n);
	vector <ULL> v2(n);
    cin.get();
	for (ULL i = 0; i < n; i++) {
        ULL a = 0;
        char c;
        while((c=cin.get())!='\n') {
            a = a*26+(c-'A');
        }
		v1[i] = a;
	}

	for (ULL i = 0; i < n; i++) {
        ULL a = 0;
        char c;
        while((c=cin.get())!='\n') {
            a = a*26+(c-'A');
        }
        v2[i] = a;
	}

	ULL count = 0;
	ULL sum1 = 0;
	ULL sum2 = 0;

	for(ULL i = 0; i < n; i++) {
		if(v1[i] == v2[i] && count == 0) {
			cout << "1" << endl;
			continue;
		}
		else {
			sum1 += v1[i];
			sum2 += v2[i];
			count++;
		}

		if(sum1 == sum2) {
			cout << count << endl;
			count = 0;
			sum1 = 0;
			sum2 = 0;
		}
	}

    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача N - New Contest Director}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_America/OC_America_N.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Создадим ассоциативный массив в котором ключ - имя кандидата, а значение - количество голосов. При считывании очередного имени, инкрементируем ему количество голосов и проверяем не стало ли его количество голосов максимальным, если стало, то записываем количество голосов в переменную $max$. Затем находим всех кандидатов у которых количество голосов равно максимальному и выводим их. Сложность $O(n)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
<>;
my %h;
my $max = 0;
while($a=<>) {
	++$h{$a};
	if ($max < $h{$a}) {
		$max = $h{$a};
	}
}
my @m = %h;
my @r;
while(($a = shift @m, $b = shift @m)) {
	if ($b == $max) {
		$a =~ s/\n//;
		push @r, $a;
	}
}
print join "\n", sort @r;
\end{lstlisting}




%----------------------------------------------------------------------------------------
%
%	Vekua Cup team
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{Vekua Cup 2015 Командный этап}

Так как соревнование проводилось в центре 1С, исходные коды программ не доступны. \\

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{Vekua_team/Vekua_team_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://vekua.snarknews.info}}}



%----------------------------------------------------------------------------------------
%
%	OpenCup GP of Ural
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{OpenCup GrandPrix of Ural}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{OC_Ural/OC_Ural_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://opencup.ru}}}

\newpage
\textbf{{\large Задача C - Древние ПСП}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Ural/OC_Ural_C.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Если дописывать сбоку по одной правильной скобочной последовательности (ПСП), то можно заметить что количество подстрок увеличивается по сумме арифметической последовательности $1, 1+2, 1+2+3, .., 1+2+..+n$, а если записывать внутрь другой скобочной последовательности, то при добавлении каждой ПСП, количество подстрок увеличивается на единицу. Программа основана на рекурсивной функции, которая на каждом шаге считает квадратное уравнение для того чтобы по количеству подстрок узнать необходимое количество ПСП записанных в ряд. Остаток от входного числа передаётся в рекурсивную функцию, результат которой будет записан вложенно в первую ПСП. Сложность $O(log(n))$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
$\ = "\n";
sub func {
	my $s = shift;
	my $a = int ((sqrt(1+8*$s)-1)/2);
	my $n = $s - ($a+1)*$a/2;
	my $r = "";
	$r = func($n) if $n != 0;
	"(". $r .")". "()" x ($a-1) ;
}
my $a = <>;
print func $a;
\end{lstlisting}

\newpage
\textbf{{\large Задача F - Фокус}}

\begin{center}
\includegraphics[width=0.9\textwidth]{OC_Ural/OC_Ural_F.png}\\ [1cm]
\end{center}
\newpage

\textbf{{\large Алгоритм}}

Если число равно нулю, то сразу выводим $-1$. Если нет, то считаем сумму цифр числа и создаём новое число с такой же суммой. Для этого последовательно вычитаем из числа девятки. Новое число будет состоять из девяток и одной цифры отличной от нуля. Если же это число получилось равно входному, то вычитаем из первой цифры $1$ и дописываем $1$ спереди. Если число больше $10^9$, выводим $-1$, а если нет, то выводим получившееся число.  Сложность $O(log(n))$\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
$a = <>;
if ($a == 0) {
	print "-1\n";
	exit;
}
@m = split "", $a;
map{$s+=$_}@m;
while ($s >= 9) {
	$r .= 9;
	$s -= 9;
}
$r .= $s if $s != 0;
if ($r == $a) {
	$r =~ s/^(\d)(\d+)(\d)$/$3$2$1/;
}
if ($r == $a) {
	$r =~ s/^(\d)(\d*)$/"1".($1-1).$2/e;
}
if ($r > 10**9) {
	print "-1\n";
	exit;
}
print $r;
\end{lstlisting}






%----------------------------------------------------------------------------------------
%
%	ЛИЧНЫЕ КОНТЕСТЫ
%
%----------------------------------------------------------------------------------------

\newpage
\section{Журнал по личным контестам Макарова Н.А.}

%----------------------------------------------------------------------------------------
%
%	Codeforces 320
%
%----------------------------------------------------------------------------------------

\subsection{Codeforces Round 320 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_320/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/579}}}

\newpage
\textbf{{\large Задача A - Выращиваем бактерии}}

\begin{center}
\includegraphics[width=0.9\textwidth]{C_320/A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно вычислить, сколько битов входного числа n являются ненулевыми. Это и будет ответом. Сложность решения $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdint.h>

int main(int argc, const char * argv[]) {
    long n = 0;
    scanf("%ld", &n);
    int i, count = 0;
    for (i = 0; i < 32; i++) {
        if (n & (1L << i)) {
            count++;
        }
    }
    printf("%d", count);
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - Ищем напарника}}

\begin{center}
\includegraphics[width=0.9\textwidth]{C_320/B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Для решения этой задачи будем использовать очередь с приоритетами. При считывании будем помечать каждого участника как не состоящего в команде, а команду вставлять в очередь с приоритемаи по силе. Затем будем доставать команды из очереди и если оба участника еще не состоят в команде, создавать из них команду. Задача решается за $O(n * log(n)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <queue>

using namespace std;

typedef struct {
    long player1;
    long player2;
    long power;
} Team;

class CompareTeams {
public:
    bool operator() (Team a, Team b) {
        return a.power < b.power;
    }
};

int main(int argc, const char * argv[]) {
    
    priority_queue<Team, vector<Team>, CompareTeams> teams;
    int n;
    cin >> n;
    for (int i = 0; i < (2 * n); i++) {
        for (int j = 0; j < i; j++) {
            long power;
            cin >> power;
            Team team;
            team.player1 = i + 1;
            team.player2 = j + 1;
            team.power = power;
            teams.push(team);
        }
    }
    
    vector<long> res(2 * n, -1);
    
    int teamCount = 0;
    
    while (teamCount != n) {
        Team team = teams.top();
        teams.pop();
        if (res[team.player1 - 1] == -1 && res[team.player2 - 1] == -1) {
            res[team.player1 - 1] = team.player2;
            res[team.player2 - 1] = team.player1;
            teamCount++;
        }
        
    }
    
    for (int i = 0; i < 2 * n; i++) {
        cout << res[i] << " ";
    }
    
    cout << endl;
    
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Codeforces 323
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 323 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_323/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/583}}}

\newpage
\textbf{{\large Задача A - Асфальтирование дорог}}

\begin{center}
\includegraphics[width=0.9\textwidth]{C_320/A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно заметить, что так как изначально не заасфальтирована ни одна дорога, то бригада сможет асфальтировать только на тех перекрестках, чьи оба индекса совпадают. Поэтому в ответ пойдет номер дня, когда индексы будут одинаковые. Решается за считывание.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>

using namespace std;

int main(int argc, const char * argv[]) {
    
    int n;
    cin >> n;
    int a, b;
    
    for (int i = 0; i < n * n; i++) {
        cin >> a >> b;
        if (a == b) {
            cout << i + 1 << " ";
        }
    }
    
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - Задача робота}}

\begin{center}
\includegraphics[width=0.9\textwidth]{C_323/B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Задача на реализацию. Нужно симулировать движение робота. Решается за $O(n^2)$.\\

\newpage

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>

using namespace std;

int main(int argc, const char * argv[])
{
    int n;
    cin >> n;
    
    vector<pair<int, bool> > v(n);
    for (int i = 0; i < n; i++) {
        pair<int, bool> temp;
        cin >> temp.first;
        temp.second = false;
        v[i] = temp;
    }
    
    int data = 0;
    int switch_count = 0;
    int i = 0;
    bool to_right = true;
    
    while (data != n) {
        if (!v[i].second && data >= v[i].first) {
            data++;
            v[i].second = true;
        }
        
        to_right ? i++ : i--;
        
        if (i == n) {
            to_right = false;
            i = n - 1;
            if (data != n) {
                switch_count++;
            }
        } else if (i == -1) {
            to_right = true;
            i = 0;
            if (data != n) {
                switch_count++;
            }
        }
    }
    
    cout << switch_count << endl;
    
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Codeforces 324
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 324 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_324/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/gym/584}}}

\newpage
\textbf{{\large Задача A - Олеся и Родион}}

\begin{center}
\includegraphics[width=0.9\textwidth]{C_324/A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно построить строку представляющую число, которое делится на $t$ и имеет длину $n$ знаков. Сначала нужно определить голову числа, это будет число, которое делится на $n$. Затем мы делаем из него число кратное 10 путем добавления оставшихся нулей. Если это количество нулей отрицательное, значит число нельзя построить и ответ будет -1. Сложность - $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=Ruby]
input = gets.split(" ")
n = input[0].to_i
t = input[1].to_i
rest = n
answer = ""
answer += t.to_s
if t == 10
	rest -= 2
else
	rest -= 1
end
if rest < 0
	puts "-1"
else
	if rest == 0
		puts answer
	else
		for i in 0...rest
			answer += "0"
		end
		puts answer
	end
end\end{lstlisting}




%----------------------------------------------------------------------------------------
%
%	Codeforces Beta 40
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Beta Round 40 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_40/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/41}}}

\newpage
\textbf{{\large Задача A - Перевод}}

\begin{center}
\includegraphics[width=0.9\textwidth]{C_40/A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно проверить, является ли одна строка реверсом другой строки. Делается стандартной функцией reverse(). Сложность $O(n)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>

using namespace std;

int main() {
    string s, t;
    cin >> s >> t;
    reverse(t.begin(), t.end());
    if (s.compare(t) == 0) {
        cout << "YES" << endl;
    } else {
        cout << "NO" << endl;
    }
    return 0;
}
\end{lstlisting}




%----------------------------------------------------------------------------------------
%
%	Codeforces 258
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 258 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_258/result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/451}}}

\newpage
\textbf{{\large Задача A - Игра с палочками}}

\begin{center}
\includegraphics[width=0.9\textwidth]{C_258/A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче достаточно заметить, что победа игрока зависит от размера сетки. Если минимальное число из размеров сетки четное, то победит Malvika, иначе победит Akshat. Сложность $O(1)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C++]
#include <iostream>
#include <algorithm>

using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    int t = n;
    
    if (n != m) {
        t = min(n, m);
    }
    
    if (t % 2 == 0) {
        cout << "Malvika" << endl;
    } else {
        cout << "Akshat" << endl;
    }
    
    return 0;
}
\end{lstlisting}




%----------------------------------------------------------------------------------------
%
%	Codeforces 274
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 274 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_274/C_274_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/480}}}

\newpage
\textbf{{\large Задача А - Выражение}}

\begin{center}
\includegraphics[width=0.9\textwidth]{C_274/C_274_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Всего может быть 6 вариантов выражения, поэтому просто переберем все варианты и выберем наибольший ответ. Сложность алгоритма $O(1)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
int main() {
    int a, b, c;
    cin >> a >> b >> c;
    int s;
    int answer = 0;
    s = a + b + c;
    if (s > answer) answer = s;
    s = a * b + c;
    if (s > answer) answer = s;
    s = a + b  * c;
    if (s > answer) answer = s;
    s = a * b * c;
    if (s > answer) answer = s;
    s = (a + b) * c;
    if (s > answer) answer = s;
    s = a * (b + c);
    if (s > answer) answer = s;
    cout << answer << endl;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - Башни}}

\begin{center}
\includegraphics[width=0.9\textwidth]{C_274/C_274_B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Отсортируем башни по высоте и будем перекладывать кубик с самой высокой на самую низкую. После этого нужно снова отсортировать новые высоты. Это нужно проделать $k$ раз. Сложность алгоритма $O(knlog(n))$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;

typedef struct {
    int n, h;
} tow;

bool cmp(const tow &a, const tow &b) {
    return a.h > b.h;
}

int main() {
    int n, k;
    cin >> n >> k;
    vector<tow> t(n);
    vector<pair<int, int>> actions;
    for (int i = 0; i < n; i++) {
        cin >> t[i].h;
        t[i].n = i + 1;
    }
    pair<int, int> move;
    int min = inf;
    vector<int> states(k + 1);
    sort(t.begin(), t.end(), cmp);
    states[0] = t[0].h - t[n - 1].h;
    for (int i = 1; i <= k; i++) {
        t[0].h--;
        t[n - 1].h++;
        move.first = t[0].n;
        move.second = t[n - 1].n;
        actions.push_back(move);
        sort(t.begin(), t.end(), cmp);
        states[i] = t[0].h - t[n - 1].h;
    }
    int minPos = -1;
    for (int i = 0; i < k + 1; i++) {
        if (states[i] < min) {
            min = states[i];
            minPos = i;
        }
    }
    cout << min << " " << minPos << endl;
    for (int i = 0; i < minPos; i++) cout << actions[i].first << " " << actions[i].second << endl;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача C - Экзамены}}

\begin{center}
\includegraphics[width=0.9\textwidth]{C_274/C_274_C.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Для решения этой задачи нужно отсортировать экзамены сначала по дате сдачи по расписанию, а затем устойчиво отсортировать по датам досрочной сдачи. Потом нужно пройти по отсортированным датам и если у текущего экзамена досрочная дата раньше чем досрочная предыдущего, то текущий нужно сдавать по расписанию. Сложность алгоритма $O(nlog(n))$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;

bool cmp_pair_first(const pair<LL, LL> &a, const pair<LL, LL> &b) {
    return a.first < b.first;
}

bool cmp_pair_second(const pair<LL, LL> &a, const pair<LL, LL> &b) {
    return (a.second < b.second) && (a.first == b.first);
}

int main() {
    int n;
    cin >> n;
    vector<pair<LL, LL>> e(n);
    LL maxFirst = -1, maxSecond = -1;
    for (int i = 0; i < n; i++) {
        cin >> e[i].first >> e[i].second;
        if (e[i].first  > maxFirst)  maxFirst  = e[i].first;
        if (e[i].second > maxSecond) maxSecond = e[i].second;
    }
    sort(e.begin(), e.end(), cmp_pair_first);
    stable_sort(e.begin(), e.end(), cmp_pair_second);
    for (int i = 1; i < n; i++) {
        if (e[i].second < e[i - 1].second) {
            e[i].second = e[i].first;
        }
    }
    cout << e[n - 1].second << endl;
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Codeforces 275
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 275 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_275/C_275_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/483}}}

\newpage
\textbf{{\large Задача C - Разнообразная перестановка}}

\begin{center}
\includegraphics[width=0.9\textwidth]{C_275/C_275_C.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Получить искомую перестановку можно записывая поочередно $b = 1$ и $e = n$. После записи $b$ нужно инкрементировать, а $e$ декрементировать. В результате будет получена искомая перестановка. Сложность алгоритма $O(n)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
using namespace std;

int main() {
    long n, k;
    cin >> n >> k;
    vector<long> v(n, 0);
    long b = 1, e = n;
    for (long i = 0; i < k; i++) {
        if (i % 2 == 0) v[i] = b++;
        else v[i] = e--;
    }
    for (long i = k; i < n; i++) {
        if (k % 2 == 1) v[i] = b++;
        else v[i] = e--;
    }
    for (auto n : v) cout << n << " ";
    cout << endl;
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	VK Cup Квалификация
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{VK Cup 2015 Квалификация}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{VK_Qual/VK_Qual_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/522}}}

\newpage
\textbf{{\large Задача A - Репосты}}

\begin{center}
\includegraphics[width=0.9\textwidth]{VK_Qual/VK_Qual_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Так как требуется найти наибольшую цепочку, то задачу можно решить поиском в глубину и запомнить наибольшую длину пути. Сложность $O(N+M)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>

#define LL  long long
#define ULL unsigned long long
using namespace std;

vector<vector<int>> g;
vector<bool> used;
int depth = 0;
int maxDepth = 0;

void dfs(int v) {
    used[v] = true;
    depth++;
    for (vector<int>::iterator i = g[v].begin(); i != g[v].end(); ++i) {
        if (!used[*i]) {
            dfs (*i);
        }
    }
    if (depth > maxDepth) {
        maxDepth = depth;
    }
    depth--;
}

int main(int argc, const char * argv[]) {
    int n;
    cin >> n;

    map<string, int> names;
    vector<pair<string, string> > log(n);
    string left, right, dummy;
    int nameNumber = 0;

    for (int i = 0; i < n; i++) {
        cin >> left >> dummy >> right;
        transform(left.begin(), left.end(), left.begin(), ::tolower);
        transform(right.begin(), right.end(), right.begin(), ::tolower);
        if (names.find(left) == names.end()) {
            names[left] = nameNumber++;
        }
        if (names.find(right) == names.end()) {
            names[right] = nameNumber++;
        }
        log[i].first = left;
        log[i].second = right;
    }

    g.resize(names.size(), vector<int>());
    used.resize(g.size());
    map<string, int>::iterator from, to;

    for (size_t i = 0; i < log.size(); i++) {
        from = names.find(log[i].second);
        to = names.find(log[i].first);
        g[from->second].push_back(to->second);
    }

    int start = names.find("polycarp")->second;
    dfs(start);
    cout << maxDepth << endl;

    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - Фото на память}}

\begin{center}
\includegraphics[width=0.9\textwidth]{VK_Qual/VK_Qual_B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно знать высоту самого высокого и второго по высоте. Это можно сделать с помощью $k$-й порядковой статистики. А потом нужно посчитать количество пикселей. Можно заметить, что высота фотографии всегда будет равна высоте самого высокого из друзей, и один раз высоте второго по высоте.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>

#define LL  long long
#define ULL unsigned long long
using namespace std;

int main() {
	int temp = 0;

	LL n;
	cin >> n;

	vector <int> width(n);
	vector <int> height(n);
	vector <int> height_2(n);

	int max_h = 0, premax_h = 0;
	LL sum_w = 0;

	for (int i = 0; i < n; i++) {

		cin >> width[i] >> height[i];
		height_2[i] = height[i];

		sum_w += width[i];
	}

	nth_element(height_2.begin(), height_2.end() - 1, height_2.end());
	max_h = height_2[n - 1];
	nth_element(height_2.begin(), height_2.end() - 2, height_2.end());
	premax_h = height_2[n - 2];

	LL temp_sum, temp_max;
	for (int i = 0; i < n; i++) {
		temp_sum = sum_w - width[i];
		if (height[i] == max_h)
			temp_max = premax_h;
		else temp_max = max_h;
		cout << temp_sum * temp_max << " ";
	}
	return 0;
}
\end{lstlisting}






%----------------------------------------------------------------------------------------
%
%	VK Cup Раунд 1
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{ VK Cup 2015 - Уайлд-кард раунд 1}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{VK_1/VK_1_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/530}}}

\newpage
\textbf{{\large Задача A - Квадратное уравнение}}

\begin{center}
\includegraphics[width=0.9\textwidth]{VK_1/VK_1_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Сложность этой задачи состоит в том, что написать ее нужно на эзотерическом языке $Picat$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
 main =>
  A = read_int(),
  B = read_int(),
  C = read_int(),

  D = (B * B) - (4 * A * C),

  X1 = ((-1)* B + sqrt(D)) / (2 *A ),

  X2 = ((-1)* B - sqrt(D)) / (2 * A),


  if(X1 < X2) then
      println(X1),
      println(X2)
      end,

  if(X1 > X2) then
      println(X2),
      println(X1)
      end,
  if(X1 == X2) then
      println(X2)
      end.
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Vekua Cup personal
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{Vekua Cup 2015 Личный этап}

Так как соревнование проводилось в центре 1С, исходные коды программ не доступны. \\

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{Vekua_personal/Vekua_personal_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://vekua.snarknews.info}}}


%----------------------------------------------------------------------------------------
%
%	RCC Квалификация
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Mail.ru Russian Code Cup 2015 Квалификация}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{RCC/RCC_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://www.russiancodecup.ru/championship/round/38/}}}

\newpage
\textbf{{\large Задача A - Покупка велосипеда}}

\begin{center}
\includegraphics[width=0.9\textwidth]{RCC/RCC_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче по числам $a$, $b$ и $c$ нужно определить, существуют ли такие $a_1$ и $b_1$, что $a_1 \leq a$, $b_1 \leq b$ и $a_1 + 2b_1 = c$. Для этого достаточно проверить, что $a + 2b \geq c$, а если $c$ -- нечетное, то проверить условие $a \geq 1$. Сложность $O(1)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
int main() {
	long t, a, b, c;
	cin >> t;
	while (t--) {
		cin >> a >> b >> c;
		if (c % 2) {
			if (a + 2*b >= c && a >= 1) {
				cout << "YES";
			} else {
				cout << "NO";
			}
		} else {
			if (a + 2*b >= c && a >= 1) {
				cout << "YES";
			} else {
				cout << "NO";
			}
		}
		cout << endl;
	}
	return 0;
}
\end{lstlisting}









\newpage
\section{Журнал по личным контестам Якименко А.В.}

%----------------------------------------------------------------------------------------
%
%	Codeforces 267
%
%----------------------------------------------------------------------------------------

\subsection{Codeforces Round 267 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_267/A_C_267_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/467}}}

\newpage
\textbf{{\large Задача A - Юра и заселение}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_267/C_267_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Задача на простую реализацию. Достаточно пройти по всем $p_i$ и $q_i$, проверить выполнение условия $p_i + 2 \leq q_i$ и если оно выполняется, то инкрементировать счетчик. Решается за $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;

int main()
{
    int count = 0;
    int n;
    cin >> n;
    for(int i=0; i<n; ++i)
    {
        int a, b;
        cin >> a >> b;
        if(a+2<=b)
            ++count;
    }
    cout << count;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - Федя и новая игра}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_267/C_267_B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно побитово сравнивать число Феди и числа других игроков и инкрементировать счетчик, если количество различных бит меньше $k$. Задача решается за $O(nb)$, где $b$ -- максимальная разрядность числа.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <map>
#include <cmath>
#include <algorithm>
#include <iomanip>
#include <list>
#include <iterator>
#include <climits>
using namespace std;
#define ll long long
#define ull unsigned long long
ll min(ll a, ll b){return (a<b?a:b);}
ll max(ll a, ll b){return (a>b?a:b);}
int main()
{
    ull n, m, k;
    cin >> n >> m >> k;
    vector<ull> v(m);
    for(ll i=0; i<m; ++i)
        cin >> v[i];
    ull x;
    cin >> x;
    ll count = 0;
    for(ll i=0; i<m; ++i)
    {
        ull a = v[i]^x;
        ull bitCount = 0;
        for(ll i=0; i<n; ++i)
            if((a>>i)&1)
                ++ bitCount;
        if(bitCount <= k)
            ++count;
    }
    cout << count;
    return 0;
}
\end{lstlisting}


%----------------------------------------------------------------------------------------
%
%	Codeforces 268
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 268 Div 2}


\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_268/A_C_268_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/469}}}

\newpage
\textbf{{\large Задача A - I Wanna Be the Guy}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_268/C_268_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче нужно проверить, дает ли объединение чисел $a_1, a_2, ... , a_p$ и $a_1, a_2, ... , a_q$ множество чисел $1, 2, ... , n$. Решается за $O(n)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdlib.h>

int main(int argc, const char * argv[]) {
    int n;
    scanf("%d", &n);
    char mas[100];
    int i;
    for(i=0; i<n; ++i)
        mas[i] = 0;
    int a, b;
    scanf("%d", &a);
    for(i=0; i<a; ++i)
    {
        scanf("%d", &b);
        mas[b-1] = 1;
    }
    scanf("%d", &a);
    for(i=0; i<a; ++i)
    {
        scanf("%d", &b);
        mas[b-1] = 1;
    }
    for(i=0; i<n; ++i)
    {
        if(mas[i] == 0)
        {
            printf("Oh, my keyboard!");
            return 0;
        }
    }
    printf("I become the guy.");
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - Онлайн чат}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_268/C_268_B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Прямой перебор в три вложенных цикла. Сложность $O(n^3)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
int main(int argc, const char * argv[]) {
    int p, q, l, r;
    cin >> p >> q >> l >> r;
    int a[51], b[51], c[51], d[51];
    for(int i=0; i<p; ++i) cin >> a[i] >> b[i];
    for(int i=0; i<q; ++i) cin >> c[i] >> d[i];
    int count = 0;
    for(int i=l; i<=r; ++i) {
        for(int j=0; j<p; ++j) {
            for(int k=0; k<q; ++k) {
                if((b[j]>=c[k]+i && b[j]<=d[k]+i)||(a[j]<=d[k]+i&&a[j]>=c[k]+i)||(c[k]+i>=a[j]&&c[k]+i<=b[j])||(d[k]+i>=a[j]&&d[k]+i<=b[j])) {
                    ++count; goto cont;
                }
            }
        }
        cont:;
    }
    cout << count;
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Codeforces Отборочный контест СГАУ на четвертьфинал ACM ICPC
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Отборочный контест СГАУ на четвертьфинал ACM-ICPC}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{CT_SGAU/A_CT_SGAU_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/gym/100488}}}

\newpage
\textbf{{\large Задача F - Два конверта}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{CT_SGAU/CT_SGAU_F.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Задача на теорию вероятности. Если в открытом конверте денег больше чем $b$, то не нужно менять выбор, иначе нужно поменять, потому что вероятность того, что в другом конверте в 2 раза меньше денег такая же, как и вероятность того, что в другом конверте в 2 раза больше денег. Сложность $O(1)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;

int main()
{
   unsigned long a, b, c;
   cin >> a >> b >> c;
   if(c>b)
	cout << "Stay with this envelope";
   else
	cout << "Take another envelope";
   return 0;
}
\end{lstlisting}


%----------------------------------------------------------------------------------------
%
%	Codeforces 269
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 269 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_269/A_C_269_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/471}}}

\newpage
\textbf{{\large Задача A - МУХ и палочки}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_269/C_269_A.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

По заданным длинам палочек идентифицируем существо, которое перед нами. Сложность $O(n)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <cctype>
#include <iostream>
#include <cstring>
#include <cmath>
#include <vector>
#include <algorithm>
#include <set>
#include <stack>
using namespace std;
long min(long a, long b){return (a<b?a:b);}
int main()
{
    vector<int> m(10, 0);
    for(int i=0; i<6; ++i)
    {
        int a;
        cin >> a;
        ++m[a];
    }
    bool beast=0, elephant=0;
    for(int i=1; i<=9; ++i)
    {
        if(m[i] >= 4)
            beast = 1;
        if(m[i] == 2 || m[i]==6)
            elephant = 1;
    }
    if(beast && elephant)
        cout << "Elephant";
    else if(beast)
        cout << "Bear";
    else
        cout << "Alien";
    return 0;
}
\end{lstlisting}


%----------------------------------------------------------------------------------------
%
%	Codeforces 270
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 270 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_270/A_C_270_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/472}}}

\newpage
\textbf{{\large Задача A - Уроки дизайна задач: учимся у математики}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_270/C_270_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Нужно найти такие числа $a$ и $b$, чтобы они не были простыми, а $a + b = n$. Для этого положим $a = 4$, а $b = n - 4$. Далее будем проверять, являются ли числа простыми. Если хоть одно из них простое, то инкрементирум $a$ и декрементируем $b$. В конце концов таким образом найдутся искомые $a$ и $b$. Сложность $O(n)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <cmath>
using namespace std;

bool prime(long long n){
    for(long long i=2;i<=sqrt(n);i++)
        if(n%i==0)
            return false;
    return true;
}

int main() {
    int n;
    cin >> n;
    for(int i=4; i<n-4; ++i) {
        if(!prime(i) && !prime(n-i)) {
            cout << i << ' ' << n-i;
            break;
        }
    }
    return 0;
}
}\end{lstlisting}

\newpage
\textbf{{\large Задача B - Уроки дизайна задач: учимся у жизни}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_270/C_270_B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Чтобы доставить всех людей на нужные этажи за наименьшее количество времени, отсортируем всех по номеру этажа и будем доставлять их порциями по вместимости лифта. Сложность $O(nlog(n))$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#define ll long long
using namespace std;
int main() {
    ll n, k;
    cin >> n >> k;
    vector<ll> v(n);
    for(ll i=0; i<n; ++i)
        cin >> v[i];
    sort(v.begin(), v.end());
    ll i = n-1;
    ll time = 0;
    while(i>=0) {
        time += v[i]*2-2;
        i -= k;
    }
    cout << time;
    return 0;
}
\end{lstlisting}

%----------------------------------------------------------------------------------------
%
%	Codeforces 272
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 272 Div 2}


\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_272/A_C_272_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/476}}}

\newpage
\textbf{{\large Задача A - Dreamoon и ступеньки}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_272/C_272_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Сначала поделим количество ступенек на два, затем будем прибавлять по единице, пока $d$ не делится на $m$ без остатка. Сложность $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <fstream>
using namespace std;

int main(int argc, const char * argv[]) {
    int n, m;
    cin >> n >> m;
    if(m>n)
    {
        cout << "-1";
        return 0;
    }
    int d = n/2+(n%2?1:0);
    while(d%m) ++d;
    cout << d;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - Dreamoon и WiFi}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_272/C_272_B1.png}\\ [1cm]
\includegraphics[width=0.9\textwidth]{C_272/C_272_B2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Для подсчёта вероятности используем формулу перестановок. Сложность $O(n)$.\\

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <cmath>
#include <iomanip>
using namespace std;
unsigned long factorial(unsigned long a)
{
    unsigned long res = 1;
    if(!a)
        return 1;
    for(long i=1; i<=a; ++i)
        res*=i;
    return res;
}
int main(int argc, const char * argv[]) {
    char c;
    int aPlus=0, aMinus=0, bPlus=0, bMinus=0, bQuest=0;
    while((c=cin.get())!='\n')
    {
        if(c=='+')
            ++aPlus;
        else if(c=='-')
            ++aMinus;
    }
    for(int i=0; i<aPlus+aMinus; ++i)
    {
        c=cin.get();
        if(c=='+')
            ++bPlus;
        else if(c=='-')
            ++bMinus;
        else if(c=='?')
            ++bQuest;
    }
    cout << fixed;
    cout << setprecision(10);
    if(aPlus<=bPlus+bQuest && aMinus<=bMinus+bQuest &&  aPlus+aMinus-(bPlus+bMinus)-bQuest == 0)
    {
        if(!bQuest)
            cout << 1;
        else
        {
            unsigned long pDiff=aPlus-bPlus;
            cout << factorial(bQuest)/(factorial(pDiff)*factorial(bQuest-pDiff))/pow(2, bQuest);
        }
    }
    else
        cout << 0;
    return 0;
}
\end{lstlisting}

%----------------------------------------------------------------------------------------
%
%	Codeforces 273
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 273 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_273/A_C_273_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/478}}}

\newpage
\textbf{{\large Задача A - Начальная ставка}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_273/C_273_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

В этой задаче достаточно заметить, что суммарное количество монет должно без остатка делиться на 5. Иначе исход игры невозможен. Сложность $O(1)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
int main(int argc, const char * argv[]) {
    int a;
    int s = 0;
    for(int i=0; i<5; ++i)
    {
        cin >> a;
        s+=a;
    }
    if(s%5 || !s)
        cout << -1;
    else
        cout << s/5;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - Случайные команды}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_273/C_273_B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Задача на комбинаторику. Минимальное количество получается если всех разделить на команды поровну, а максимальное если в одну из команд поместить максимально возможное количество участников. Сложность $O(nlog(1))$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;

int main(int argc, const char * argv[]) {
    unsigned long long m, n;
    cin >> m >> n;
    unsigned long long min, max;
    unsigned long long k = (m-n+1);
    max = k*(k-1)/2;
    unsigned long long r = m%n;
    if(r)
    {
        k = m/n;
        min = k*(k-1)/2*(n-r)+(k+1)*k/2*r;
    }
    else
    {
        k = m/n;
        min = k*(k-1)/2*n;
    }
    if(min>max)
    {
        cout << max << ' ' << min;
    }
    else
        cout << min << ' ' << max;
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Codeforces 274
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 274 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_274/A_C_274_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/480}}}

\newpage
\textbf{{\large Задача A - Выражение}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_274/C_274_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Напишем условия для каждого случая. Таким образом программа будет работать за $O(1)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
int main(int argc, const char * argv[]) {
    int a, b, c;
    cin >> a >> b >> c;
    if(a==1) {
        if(c==1) cout << a+b+c;
        else cout << (a+b)*c;
    } else {
        if(b==1) {
            if(a>c) cout << a*(b+c);
            else cout << (a+b)*c;
        } else {
            if(c==1) cout << a*(b+1);
            else cout << a*b*c;
        }
    }
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - Башни}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_274/C_274_B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Отсортируем башни по высоте и будем перекладывать кубик с самой высокой на самую низкую. После этого нужно снова отсортировать новые высоты. Это нужно проделать $k$ раз. Сложность алгоритма $O(knlog(n))$\\

\textbf{{\large Исходный код}}\\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
struct myPair {
    int from, to;
};
struct Tower {
    int id, h;
};
bool compareByH(const Tower &a, const Tower &b) {
    return a.h < b.h;
}
int main(int argc, const char * argv[]) {
    int n, k;
    vector<Tower> m(101);
    myPair mP[1001];
    bool u[101];
    cin >> n >> k;
    for(int i=0; i<n; ++i)
    {
        cin >> m[i].h;
        m[i].id = i+1;
        u[i] = 0;
    }
    sort(m.begin(), m.begin()+n, compareByH);

    int minK = k, diff = -1;
    for(int i=0; i<k; ++i)
    {
        int min, max;
        int minIndex = 0, maxIndex = n-1;
        while(minIndex<n-1 && m[minIndex].h>=m[minIndex+1].h && !u[minIndex+1])++minIndex;
        while(maxIndex>0 && m[maxIndex].h<=m[maxIndex-1].h)--maxIndex;
        min = m[minIndex].h;
        max = m[maxIndex].h;
        u[maxIndex] = 1;
        if(u[minIndex])
        {
            minK = i;
            break;
        }
        if(max-min == 1)
        {
            diff = 1;
            minK = i;
            break;
        }
        else if(max-min == 0)
        {
            diff = 0;
            minK = i;
            break;
        }
        mP[i].from = m[maxIndex].id;
        mP[i].to = m[minIndex].id;
        --m[maxIndex].h;
        ++m[minIndex].h;
    }
    if(diff == -1)
    {
        int minIndex = 0, maxIndex = n-1;
        while(minIndex<n-1 && m[minIndex].h>=m[minIndex+1].h)++minIndex;
        while(maxIndex>0 && m[maxIndex].h<=m[maxIndex-1].h)--maxIndex;
        diff = m[maxIndex].h - m[minIndex].h;
    }
    cout << diff << ' ' << minK << '\n';
    for(int i=0; i<minK; ++i)
    {
        cout << mP[i].from << ' ' << mP[i].to << '\n';
    }
    return 0;
}
\end{lstlisting}
\newpage
\textbf{{\large Задача C - Экзамены}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_274/C_274_C.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Для решения этой задачи нужно отсортировать экзамены сначала по дате сдачи по расписанию, а затем устойчиво отсортировать по датам досрочной сдачи. Потом нужно пройти по отсортированным датам и если у текущего экзамена досрочная дата раньше чем досрочная предыдущего, то текущий нужно сдавать по расписанию. Сложность алгоритма $O(nlog(n))$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
bool compareFirst(const pair<int, int> &a, const pair<int, int> &b)
{
    return a.first < b.first;
}
bool compareSecond(const pair<int, int> &a, const pair<int, int> &b)
{
    return a.second < b.second;
}
int main(int argc, const char * argv[]) {
    int n;
    cin >> n;
    vector< pair<int,int> > m(n);
    for(int i=0; i<n; ++i)
        cin >> m[i].first >> m[i].second;
    stable_sort(m.begin(), m.end(), compareSecond);
    stable_sort(m.begin(), m.end(), compareFirst);
    int res = m[0].second;
    for(int i=1; i<n; ++i)
    {
        if(m[i].second >= res)
            res = m[i].second;
        else
            res = m[i].first;
    }
    cout << res;
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Codeforces 275
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 275 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_275/A_C_275_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/483}}}

\newpage
\textbf{{\large Задача A - Опровержение гипотез}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_275/C_275_C.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Используем обычный перебор. Сложность $O(n^3)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
using namespace std;
unsigned long long min(unsigned long long a, unsigned long long b){return (a>b)?a:b;}
unsigned long long gcd (unsigned long long a, unsigned long long b) {
    while (b) {
        a %= b;
        swap (a, b);
    }
    return a;
}
int main(int argc, const char * argv[]) {
    unsigned long long l,r;
    cin >> l >> r;
    for(unsigned long long a=l; a<=r; ++a)
    {
        for(unsigned long long b=a+1; b<r; ++b)
        {
            for(unsigned long long c=b+1; c<=r; ++c)
            {
                if(gcd(a,b)==1 && gcd(b,c)==1 && gcd(a,c)>1)
                {
                    cout << a << ' ' << b << ' ' << c;
                    return 0;
                }
            }
        }
    }
    cout << -1;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача C - Разнообразная перестановка}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_275/C_275_C.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Получить искомую перестановку можно записывая поочередно $b = 1$ и $e = n$. После записи $b$ нужно инкрементировать, а $e$ декрементировать. В результате будет получена искомая перестановка. Сложность алгоритма $O(n)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <cmath>
#define MAX 100002
using namespace std;
int main(int argc, const char * argv[]) {
    long n, k;
    cin >> n >> k;
    cout << "1 ";
    long a = k+1, b=2;
    for(unsigned long long i=1; i<=k; ++i)
    {
        if(i%2)
            cout << a--<< ' ';
        else
            cout << b++ << ' ';
    }
    for(long i=k+2; i<=n; ++i)
    {
        cout << i << ' ';
    }
    return 0;
}
\end{lstlisting}


%----------------------------------------------------------------------------------------
%
%	Codeforces 276
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 276 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_276/A_C_276_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/485}}}

\newpage
\textbf{{\large Задача A - Фабрика}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_276/C_276_A.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Производство не остановится тогда, когда $t$ будет повторяться. Чтобы это проверить нужно создать булевский массив и заполнить его нулями. В цикле присваивать единицу элементу с индексом $t$, если элемент уже равен единице, то вывести $No$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <cctype>
#include <iostream>
#include <cstring>
#include <cmath>
#include <vector>
#include <algorithm>
#include <set>
#include <stack>
using namespace std;
long min(long a, long b){return (a<b?a:b);}
bool prime(long long n){
    for(long long i=2;i<=sqrt(n);i++)
        if(n%i==0)
            return false;
    return true;
}
int main()
{
    long long a, m;
    cin >> a >> m;
    vector<bool> v(m+1, 0);
    while(a)
    {
        long long t = a%m;
        if(!t)
        {
            cout << "Yes";
            return 0;
        }
        if(v[t])
        {
            cout << "No";
            return 0;
        }
        v[t] = 1;
        a += t;
    }
    cout << "No";
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - Ценные ресурсы}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_276/C_276_B.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Нужно найти минимальную и максимальную координаты и посчитать площадь прямоугольника между ними. Сложность $O(n)$.\\

\textbf{{\large Исходный код}} \\ 
\begin{lstlisting}[language=C]
#include <cctype>
#include <iostream>
#include <cstring>
#include <cmath>
#include <vector>
#include <algorithm>
#include <set>
#include <stack>
using namespace std;
long min(long a, long b){return (a<b?a:b);}

int main()
{
    long long n;
    cin >> n;
    long long minX, minY, maxX, maxY;
    cin >> minX >> minY;
    maxX = minX;
    maxY = minY;
    for(int i=1; i<n; ++i)
    {
        long long a, b;
        cin >> a >> b;
        if(a<minX)
            minX = a;
        else if(a>maxX)
            maxX = a;
        if(b<minY)
            minY = b;
        else if(b>maxY)
            maxY = b;
    }
    long long t = max(abs(maxX-minX), abs(maxY-minY));
    cout << t*t;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача C - Биты}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_276/C_276_C.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Заполняем число, изначально равное нижней границе, в двоичном представлении единицами и до тех пор пока оно не приблизится к верхней. Сложность $O(log(n))$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <cctype>
#include <iostream>
#include <vector>
using namespace std;
long min(long a, long b){return (a<b?a:b);}
int main() {
    long long n;
    cin >> n;
    long long minX, minY, maxX, maxY;
    cin >> minX >> minY;
    maxX = minX; maxY = minY;
    for(int i=1; i<n; ++i) {
        long long a, b;
        cin >> a >> b;
        if(a<minX)
            minX = a;
        else if(a>maxX)
            maxX = a;
        if(b<minY)
            minY = b;
        else if(b>maxY)
            maxY = b;
    }
    long long t = max(abs(maxX-minX), abs(maxY-minY));
    cout << t*t;
    return 0;
}
\end{lstlisting}


%----------------------------------------------------------------------------------------
%
%	Codeforces 277
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 277 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_277/A_C_277_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/486}}}

\newpage
\textbf{{\large Задача A - Подсчёт функции}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_277/C_277_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Выводим входное число делённое на два, округленное в большую сторону и умноженное на $-1$, если входное число нечётное. Сложность $O(1)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <climits>
#define ll long long
#define ull unsigned long long
using namespace std;
int main()
{
    ll n = 0;
    cin >> n;
    ll r = n-n/2;
    cout << (n&1?-r:r);
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - OR в матрице}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_277/C_277_B1.png}\\
\includegraphics[width=0.9\textwidth]{C_277/C_277_B2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Сложность $O(n^3)$.

\newpage
\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <climits>
#define ll long long
#define ull unsigned long long
using namespace std;
int main()
{
    ll m, n;
    cin >> m >> n;
    bool matrix[101][101];
    bool newMatrix[101][101];
    for(ll i=0; i<m; ++i)
    {
        for(ll j=0; j<n; ++j)
        {
            cin >> matrix[i][j];
            newMatrix[i][j] = 0;
        }
    }
    vector<bool> markx(100, 0);
    vector<bool> marky(100, 0);
    for(ll i=0; i<m; ++i)
    {
        for(ll j=0; j<n; ++j)
        {
            if(matrix[i][j])
            {
                bool ok1 = 1, ok2 = 1, okok1=0, okok2=0;
                for(ll ii=0; ii<m; ++ii)
                {
                    bool f = 1;
                    for(ll jj = 0; jj<n; ++jj)
                    {
                        if(!matrix[ii][jj])
                        {
                            f = 0;
                            break;
                        }
                    }
                    if(f)
                    {
                        okok1 = 1;
                    }
                    if(!matrix[ii][j])
                    {
                        ok1 = 0;
                        break;
                    }
                }
                for(ll jj=0; jj<n; ++jj)
                {
                    bool f = 1;
                    for(ll ii = 0; ii<m; ++ii)
                    {
                        if(!matrix[ii][jj])
                        {
                            f = 0;
                            break;
                        }
                    }
                    if(f)
                    {
                        okok2 = 1;
                    }
                    if(!matrix[i][jj])
                    {
                        ok2 = 0;
                        break;
                    }
                }
                if(!((ok1&&okok1) || (ok2&&okok2)))
                {
                    cout << "NO";
                    return 0;
                }
            }
        }
    }
    for(ll i=0; i<m; ++i)
    {
        for(ll j=0; j<n; ++j)
        {
            bool ok1 = 1, ok2 = 1;
            for(ll ii=0; ii<m; ++ii)
            {
                if(!matrix[ii][j])
                {
                    ok1 = 0;
                    break;
                }
            }
            for(ll jj=0; jj<n; ++jj)
            {
                if(!matrix[i][jj])
                {
                    ok2 = 0;
                    break;
                }
            }
            if(ok1 && ok2)
                newMatrix[i][j] = 1;
        }
    }
    cout << "YES\n";
    for(ll i=0; i<m; ++i)
    {
        for(ll j=0; j<n; ++j)
        {
            cout << newMatrix[i][j] << ' ';
        }
        cout.put('\n');
    }
    return 0;
}
\end{lstlisting}





%----------------------------------------------------------------------------------------
%
%	Codeforces 277.5
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{Codeforces Round 277.5 Div 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{C_277_5/A_C_277_5_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/489}}}

\newpage
\textbf{{\large Задача A - SwapSort}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_277_5/C_277_5_A.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

На каждом шаге будем находить минимальный элемент и обменивать его с элементом под текущим индексом. Сложность $O(n^2)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <map>
using namespace std;
#define ll long long
#define ull unsigned long long

int main()
{
    ll n;
    cin >> n;
    ll m[3000];
    for(int i=0; i<n; ++i)
        cin >> m[i];
    cout << n << '\n';
    for(int i=0; i<n; ++i)
    {
        ll min = 1000000001, minIndex = -1;
        for(int j=i; j<n; ++j)
        {
            if(m[j] < min)
            {
                min = m[j];
                minIndex = j;
            }
        }
        swap(m[i], m[minIndex]);
        cout << i << ' ' << minIndex << '\n';
    }
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача B - Бал в БерлГУ}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_277_5/C_277_5_B1.png}\\
\includegraphics[width=0.9\textwidth]{C_277_5/C_277_5_B2.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Отсортируем парней и девушек. Будем брать парня и девушку, если между ними разница не больше единицы, если же пара не получается, то переходим к другому парню или девушке (в зависимости от того, у кого индекс больше). Сложность после сортировки $O(n+m)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <map>
#include <cmath>
#include <algorithm>
#include <iomanip>
using namespace std;
#define ll long long
#define ull unsigned long long

int main()
{
    ll n, m;
    cin >> n;
    vector<ll> boys(n);
    for(ll i=0; i<n; ++i)
        cin >> boys[i];
    sort(boys.begin(), boys.end());
    cin >> m;
    vector<ll> girls(m);
    for(ll i=0; i<m; ++i)
        cin >> girls[i];
    sort(girls.begin(), girls.end());
    ll count = 0;
    for(ll i=0, j=0; i<n && j<m;)
    {
        if(boys[i] >= girls[j]-1 && boys[i] <= girls[j]+1)
        {
            ++i;
            ++j;
            ++count;
        }
        else if(boys[i] < girls[j])
            ++i;
        else
            ++j;
    }
    cout << count;
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача C - Даны длина и сумма цифр...}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_277_5/C_277_5_C.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Будем собирать число из девяток, если же нужно больше цифр, то раскладываем девятки на слагаемые, если это невозможно, то выводим $"-1 -1"$. Сложность $O(n)$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <map>
using namespace std;
#define ll long long
#define ull unsigned long long

int main()
{
    ll m, s;
    cin >> m >> s;
    if(m>1 && !s)
    {
        cout << "-1 -1";
        return 0;
    }
    else if(m == 1 && !s)
    {
        cout << "0 0";
        return 0;
    }
    char v[101];
    ll i = 0;
    while(s>0)
    {
        if(s >= 9)
            v[i++] = 9;
        else
            v[i++] = s;
        s -= 9;
    }
    ll n = i-1;
    if(i > m)
    {
        cout << "-1 -1";
        return 0;
    }
    for(; i<m; ++i)
    {
        v[i] = 0;
    }
    --v[n];
    ++v[m-1];
    for(ll i=m-1; i>=0; --i)
        cout << (int)v[i];
    cout.put(' ');
    ++v[n];
    --v[m-1];
    for(ll i=0; i<m; ++i)
        cout << (int)v[i];
    return 0;
}
\end{lstlisting}

\newpage
\textbf{{\large Задача D - Невыносимая запутанность бытия}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{C_277_5/C_277_5_D1.png}\\
\includegraphics[width=0.9\textwidth]{C_277_5/C_277_5_D2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Из каждой вершины пробуем попасть в другую через промежуточные вершины, подсчитываем удачные попытки. Сложность $O(n^2*log(n))$. \\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <map>
#include <cmath>
#include <algorithm>
#include <iomanip>
#include <list>
#include <iterator>
using namespace std;
#define ll long long
#define ull unsigned long long

int main()
{
    ll n, m;
    cin >> n >> m;
    vector< pair< list<int>, list<int> > > l(n+1);
    vector< vector<bool> > matrix(n+1, vector<bool>(n+1, 0));
    for(ll i=0; i<m; ++i)
    {
        int a, b;
        cin >> a >> b;
        l[b].first.insert(l[b].first.end(), a);
        l[a].second.insert(l[a].second.end(), b);
        matrix[a][b] = 1;
    }
    ll count = 0;
    for(int i=1; i<=n; ++i)
    {
        for(int j=i+1; j<=n; ++j)
        {
            list<int>::iterator it = l[i].first.begin();
            ll a = 0, b = 0, c = 0;
            for(;it!=l[i].first.end(); ++it)
                if(*it!=j && matrix[*it][j])
                {
                    ++a;
                    if(matrix[j][*it] && matrix[i][*it])
                        ++c;
                }
            it = l[i].second.begin();
            for(;it!=l[i].second.end(); ++it)
                if(*it!=j && matrix[j][*it])
                    ++b;
            count += a*b-c;
        }
    }
    cout << count;
    return 0;
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	VK Cup Квалификация 2
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{VK Cup 2015 Квалификация 2}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{VK_Qual_2/A_VK_Qual_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/523}}}

\newpage
\textbf{{\large Задача A - Поворот, отражение и масштабирование}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{VK_Qual_2/VK_Qual_A1.png}\\
\includegraphics[width=0.9\textwidth]{VK_Qual_2/VK_Qual_A2.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Считываем картинку и выводим её просто поменяв индексы местами и индекс $i$ поделив на два. Сложность $O(n)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <cmath>
#include <algorithm>
#include <iomanip>
#include <list>
#include <iterator>
#include <climits>
#include <stack>
#include <cstring>
#include <cctype>
#include <queue>
#include <set>
using namespace std;
#define ll long long
#define ull unsigned long long
#define eps 0.00001
ll min(ll a, ll b){return (a<b?a:b);}
ll max(ll a, ll b){return (a>b?a:b);}

int main()
{
    ll w, h;
    cin >> w >> h;
    char map[101][101];
    for (int i=0; i<h; ++i) {
        cin >> map[i];
    }
    for (int i=0; i<w*2; ++i) {
        for (int j=0; j<h; ++j) {
            cout.put(map[j][i/2]);
            cout.put(map[j][i/2]);
        }
        cout.put('\n');
    }
    return 0;
}
\end{lstlisting}
\newpage
\textbf{{\large Задача C - В поисках имени}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{VK_Qual_2/VK_Qual_C.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Находим подстроку слева и справа и считаем расстояние между ними. Сложность $O(n)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <cmath>
#include <algorithm>
#include <iomanip>
#include <list>
#include <iterator>
#include <climits>
#include <stack>
#include <cstring>
#include <cctype>
#include <queue>
#include <set>
using namespace std;
#define ll long long
#define ull unsigned long long
#define eps 0.00001
ll min(ll a, ll b){return (a<b?a:b);}
ll max(ll a, ll b){return (a>b?a:b);}

int main()
{
    char s[1001], t[1000001];
    cin >> s >> t;
    ll s_len = strlen(s);
    ll t_len = strlen(t);
    ll sLCursor = 0, sRCursor = s_len - 1, l = -1, r = -1;
    for (ll i=0; i<t_len; ++i) {
        if (s[sLCursor] == t[i]) {
            ++sLCursor;
            if (sLCursor == s_len) {
                l = i;
                break;
            }
        }
    }
    for (ll i=t_len-1; i>=0; --i) {
        if (s[sRCursor] == t[i]) {
            --sRCursor;
            if (sRCursor == -1) {
                r = i;
                break;
            }
        }
    }
    if (l == -1 || r == -1 || l >= r) {
        cout << 0;
    }
    else {
        cout << r-l;
    }
    return 0;
}
\end{lstlisting}

%----------------------------------------------------------------------------------------
%
%	VK Cup Раунд 1
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{ VK Cup 2015 - Раунд 1}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{VK_R_1/A_VK_1_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/524}}}

\newpage
\textbf{{\large Задача A - Возможно, вы знаете этих людей?}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{VK_R_1/VK_1_A1.png}\\
\includegraphics[width=0.9\textwidth]{VK_R_1/VK_1_A2.png}\\ [1cm]
\end{center}

\newpage
\textbf{{\large Алгоритм}}

Создаём граф друзей и затем, для каждого друга находим возможных друзей, если процент общих друзей больше заданного. Сложность $O(n^2)$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <cmath>
#include <algorithm>
#include <iomanip>
#include <list>
#include <iterator>
#include <climits>
#include <stack>
#include <cstring>
#include <cctype>
#include <queue>
#include <set>
using namespace std;
#define ll long long

map<ll, pair<ll, set<ll> > > p;

void add_friend(ll a, ll b) {
    map<ll, pair<ll, set<ll> > >::iterator findIter = p.find(a);
    if (findIter == p.end()) {
        set<ll> t;
        t.insert(b);
        p[a] = make_pair(a, t);
    }
    else {
        p[a].second.insert(b);
    }
}

int main()
{
    ll m;
    double k;
    cin >> m >> k;
    for (ll i=0; i<m; ++i) {
        ll a, b;
        cin >> a >> b;
        add_friend(a, b);
        add_friend(b, a);
    }
    map<ll, pair<ll, set<ll> > >::iterator iter;
    for ( iter = p.begin(); iter != p.end(); ++iter) {
        ll a = iter->first;
        cout << a << ": ";
        map<ll, pair<ll, set<ll> > >::iterator iter2;
        list<ll> p_friends;
        for ( iter2 = p.begin(); iter2 != p.end(); ++iter2) {
            if (iter2->first == a) {
                continue;
            }
            set<ll>::iterator findIter = find(p[a].second.begin(), p[a].second.end(), iter2->first);
            if (findIter == p[a].second.end()) {
                ll c = iter2->first;
                set<ll>::iterator setIter = p[a].second.begin();
                ll o = 0;
                for ( ; setIter != p[a].second.end(); ++setIter) {
                    ll b = *setIter;
                    if (p[b].second.find(c) != p[b].second.end()) {
                        ++o;
                    }
                }
                ll kokoko = o*100/p[a].second.size();
                if (kokoko >= k) {
                    p_friends.push_back(c);
                }

            }
        }
        cout << p_friends.size() << ' ';
        list<ll>::iterator it = p_friends.begin();
        for ( ; it != p_friends.end(); ++it) {
            cout << *it << ' ';
        }
        cout << '\n';
    }
    return 0;
}
\end{lstlisting}


%----------------------------------------------------------------------------------------
%
%	VK Cup Раунд 1 Уайлд-кард
%
%----------------------------------------------------------------------------------------

\newpage
\subsection{ VK Cup 2015 - Уайлд-кард раунд 1}

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{VK_1/A_VK_1_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://codeforces.com/contest/530}}}

\newpage
\textbf{{\large Задача A - Квадратное уравнение}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{VK_1/VK_1_A.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Сложность этой задачи состоит в том, что написать ее нужно на эзотерическом языке $Picat$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
main =>
    A = read_int(),
    B = read_int(),
    C = read_int(),
    D = B*B-4*A*C,
        if (D == 0) then
            writef("%w%n",-B/(2*A))
        elseif ((-B+sqrt(D))/(2*A) < (-B-sqrt(D))/(2*A)) then
                writef("%w %w%n", (-B+sqrt(D))/(2*A), (-B-sqrt(D))/(2*A))
        else
                writef("%w %w%n", (-B-sqrt(D))/(2*A), (-B+sqrt(D))/(2*A))
        end.
\end{lstlisting}
\newpage

\textbf{{\large Задача B - Строка наизнанку}} \\
\begin{center}
\includegraphics[width=0.9\textwidth]{VK_1/VK_1_B.png}\\ [1cm]
\end{center}

\textbf{{\large Алгоритм}}

Сложность этой задачи состоит в том, что написать ее нужно на эзотерическом языке $Picat$.\\

\textbf{{\large Исходный код}} \\
\begin{lstlisting}[language=C]
main =>
    S = read_line(),
    L = S.length,
    X1 = to_integer(L/2),
    X2 = X1+1,
    S1 = reverse(slice(S, 1, X1)),
    S2 = reverse(slice(S, X2, L)),
    printf("%s%s", S1,S2).
\end{lstlisting}



%----------------------------------------------------------------------------------------
%
%	Vekua Cup personal
%
%----------------------------------------------------------------------------------------
\newpage
\subsection{Vekua Cup 2015 Личный этап}

Так как соревнование проводилось в центре 1С, исходные коды программ не доступны. \\

\textbf{{\large Результаты}} \\
\begin{center}
\includegraphics[width=0.95\textwidth]{Vekua_personal/A_Vekua_personal_result.png}\\ [1cm]
\end{center}

\textbf{{\large Ссылка на контест: \url{http://vekua.snarknews.info}}}




\end{document}
